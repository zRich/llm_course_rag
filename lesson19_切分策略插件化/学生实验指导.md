# 第十九节课 学生实验指导：切分策略插件化

## 实验目标

通过本次实验，你将学会：
1. 理解插件化架构的设计思想
2. 掌握策略模式的实际应用
3. 实现可扩展的文档切分系统
4. 学会性能测试和优化方法

## 实验环境准备

### 1. 切换到实验分支
```bash
cd /path/to/rag-system
git checkout lesson19
```

### 2. 安装依赖
```bash
pip install -r requirements.txt
```

### 3. 验证环境
```bash
python -c "import nltk; print('环境准备完成')"
```

## 实验内容

### 实验一：理解插件化架构 (10分钟)

#### 1.1 查看核心框架

打开 `lesson19_chunk_strategies/core/strategy_base.py`，理解策略基类：

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Any

class ChunkStrategy(ABC):
    """切分策略基类"""
    
    def __init__(self, **kwargs):
        self.config = kwargs
    
    @abstractmethod
    def chunk(self, text: str) -> List[str]:
        """切分文本的核心方法"""
        pass
    
    @abstractmethod
    def get_info(self) -> Dict[str, Any]:
        """获取策略信息"""
        pass
```

#### 1.2 查看注册机制

查看 `lesson19_chunk_strategies/core/registry.py`：

```python
class StrategyRegistry:
    """策略注册器"""
    _strategies = {}
    
    @classmethod
    def register(cls, name: str):
        """策略注册装饰器"""
        def decorator(strategy_class):
            cls._strategies[name] = strategy_class
            return strategy_class
        return decorator
    
    @classmethod
    def get_strategy(cls, name: str):
        """获取策略类"""
        return cls._strategies.get(name)
    
    @classmethod
    def list_strategies(cls):
        """列出所有策略"""
        return list(cls._strategies.keys())
```

#### 思考题
1. 为什么要使用抽象基类？
2. 装饰器注册的优势是什么？

### 实验二：实现基础切分策略 (15分钟)

#### 2.1 固定长度策略

在 `lesson19_chunk_strategies/strategies/fixed_length.py` 中实现：

```python
from ..core.strategy_base import ChunkStrategy
from ..core.registry import StrategyRegistry
from typing import List, Dict, Any

@StrategyRegistry.register("fixed_length")
class FixedLengthStrategy(ChunkStrategy):
    """固定长度切分策略"""
    
    def __init__(self, chunk_size=1000, overlap=100, **kwargs):
        super().__init__(**kwargs)
        self.chunk_size = chunk_size
        self.overlap = overlap
    
    def chunk(self, text: str) -> List[str]:
        """按固定长度切分文本"""
        chunks = []
        start = 0
        
        while start < len(text):
            end = start + self.chunk_size
            chunk = text[start:end]
            
            if chunk.strip():  # 跳过空白块
                chunks.append(chunk.strip())
            
            start = end - self.overlap
            
            if start >= len(text):
                break
        
        return chunks
    
    def get_info(self) -> Dict[str, Any]:
        return {
            "name": "固定长度切分",
            "chunk_size": self.chunk_size,
            "overlap": self.overlap,
            "description": "按照固定字符数切分文本，支持重叠"
        }
```

#### 2.2 语义切分策略

在 `lesson19_chunk_strategies/strategies/semantic.py` 中实现：

```python
import re
from ..core.strategy_base import ChunkStrategy
from ..core.registry import StrategyRegistry
from typing import List, Dict, Any

@StrategyRegistry.register("semantic")
class SemanticStrategy(ChunkStrategy):
    """语义切分策略"""
    
    def __init__(self, max_chunk_size=1500, **kwargs):
        super().__init__(**kwargs)
        self.max_chunk_size = max_chunk_size
        # 句子结束标记
        self.sentence_endings = re.compile(r'[.!?。！？]\s+')
    
    def chunk(self, text: str) -> List[str]:
        """按语义边界切分文本"""
        # 按句子分割
        sentences = self.sentence_endings.split(text)
        
        chunks = []
        current_chunk = ""
        
        for sentence in sentences:
            sentence = sentence.strip()
            if not sentence:
                continue
            
            # 如果加入当前句子后超过最大长度，先保存当前块
            if len(current_chunk) + len(sentence) > self.max_chunk_size:
                if current_chunk:
                    chunks.append(current_chunk.strip())
                    current_chunk = sentence
                else:
                    # 单个句子就超长，直接添加
                    chunks.append(sentence)
            else:
                current_chunk += (" " if current_chunk else "") + sentence
        
        # 添加最后一个块
        if current_chunk.strip():
            chunks.append(current_chunk.strip())
        
        return chunks
    
    def get_info(self) -> Dict[str, Any]:
        return {
            "name": "语义切分",
            "max_chunk_size": self.max_chunk_size,
            "description": "按照句子边界进行语义切分"
        }
```

#### 实验任务
1. 运行测试代码验证两个策略
2. 比较两种策略的切分效果
3. 调整参数观察结果变化

### 实验三：自定义策略实现 (15分钟)

#### 3.1 任务要求
实现一个**段落切分策略**，要求：
- 按照段落（双换行符）进行切分
- 如果段落过长，再按句子切分
- 支持最小和最大段落长度配置

#### 3.2 实现模板

在 `lesson19_chunk_strategies/strategies/paragraph.py` 中实现：

```python
# TODO: 学生完成实现
@StrategyRegistry.register("paragraph")
class ParagraphStrategy(ChunkStrategy):
    """段落切分策略"""
    
    def __init__(self, min_chunk_size=200, max_chunk_size=1200, **kwargs):
        super().__init__(**kwargs)
        self.min_chunk_size = min_chunk_size
        self.max_chunk_size = max_chunk_size
    
    def chunk(self, text: str) -> List[str]:
        """按段落切分文本"""
        # TODO: 实现段落切分逻辑
        pass
    
    def get_info(self) -> Dict[str, Any]:
        return {
            "name": "段落切分",
            "min_chunk_size": self.min_chunk_size,
            "max_chunk_size": self.max_chunk_size,
            "description": "按照段落边界进行切分，支持长度控制"
        }
```

#### 3.3 实现提示
1. 使用 `text.split('\n\n')` 按段落分割
2. 检查每个段落的长度
3. 过短的段落可以合并
4. 过长的段落需要进一步切分

### 实验四：策略测试与比较 (5分钟)

#### 4.1 运行测试脚本

```bash
python lesson19_chunk_strategies/test_strategies.py
```

#### 4.2 性能比较

查看 `lesson19_chunk_strategies/benchmark.py` 的输出：

```python
# 示例输出
策略性能比较:
固定长度策略: 平均块大小=987, 处理时间=0.05s
语义切分策略: 平均块大小=1156, 处理时间=0.12s
段落切分策略: 平均块大小=1089, 处理时间=0.08s
```

#### 4.3 分析结果
1. 哪种策略的切分效果最好？
2. 性能和效果如何平衡？
3. 不同文档类型适合哪种策略？

## 进阶实验（可选）

### 进阶一：策略组合

实现一个组合策略，可以串联多个策略：

```python
@StrategyRegistry.register("combined")
class CombinedStrategy(ChunkStrategy):
    """组合策略"""
    
    def __init__(self, strategies=None, **kwargs):
        super().__init__(**kwargs)
        self.strategies = strategies or []
    
    def chunk(self, text: str) -> List[str]:
        """依次应用多个策略"""
        result = [text]
        
        for strategy_name in self.strategies:
            strategy_class = StrategyRegistry.get_strategy(strategy_name)
            if strategy_class:
                strategy = strategy_class()
                new_result = []
                for chunk in result:
                    new_result.extend(strategy.chunk(chunk))
                result = new_result
        
        return result
```

### 进阶二：智能策略选择

根据文档特征自动选择最佳策略：

```python
class SmartStrategySelector:
    """智能策略选择器"""
    
    def select_strategy(self, text: str) -> str:
        """根据文本特征选择策略"""
        # 分析文本特征
        avg_sentence_length = self._get_avg_sentence_length(text)
        paragraph_count = text.count('\n\n')
        
        # 选择策略
        if paragraph_count > 5:
            return "paragraph"
        elif avg_sentence_length > 100:
            return "semantic"
        else:
            return "fixed_length"
```

## 实验报告要求

### 必答题
1. 描述插件化架构的核心思想
2. 比较三种切分策略的优缺点
3. 解释策略注册机制的工作原理

### 实验结果
1. 提交自定义段落切分策略的代码
2. 提供性能测试结果截图
3. 分析不同策略的适用场景

### 思考题
1. 如何实现策略的热插拔？
2. 如何处理策略执行失败的情况？
3. 如何设计策略的配置管理系统？

## 常见问题解答

### Q1: 策略注册失败怎么办？
**A**: 检查导入路径和装饰器使用是否正确。

### Q2: 如何调试策略执行过程？
**A**: 在策略方法中添加日志输出，使用调试器逐步执行。

### Q3: 性能测试结果不准确？
**A**: 多次运行取平均值，确保测试数据足够大。

## 参考资源

- [Python装饰器详解](https://docs.python.org/3/glossary.html#term-decorator)
- [策略模式实现指南](https://refactoring.guru/design-patterns/strategy/python/example)
- [文本处理最佳实践](https://docs.python.org/3/library/re.html)

## 课后练习

1. **基础练习**: 实现一个基于关键词的切分策略
2. **进阶练习**: 添加策略执行的性能监控
3. **挑战练习**: 设计一个支持插件热加载的系统