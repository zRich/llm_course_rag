# 第十三节课：引用与可溯源输出 - 学生实验指导

## 实验概述

**实验时长**：15分钟  
**实验目标**：实现RAG系统的引用与可溯源输出功能  
**实验环境**：Python 3.8+, 已完成前面课程的RAG系统搭建  

## 实验准备

### 1. 确认环境
确保你已经完成了前面课程的实验，特别是：
- 文档处理和分块系统
- 向量检索系统
- 重排序模型集成

### 2. 实验文件结构
```
rag-system/
├── citation_system.py          # 引用系统核心实现
├── citation_formatter.py       # 引用格式化工具
├── confidence_calculator.py    # 置信度计算模块
├── test_citation.py           # 测试脚本
└── sample_docs/               # 测试文档
    ├── doc1.pdf
    ├── doc2.txt
    └── doc3.docx
```

## 实验步骤

### 步骤1：实现引用信息数据结构（3分钟）

创建 `citation_system.py` 文件：

```python
from dataclasses import dataclass
from typing import List, Dict, Optional
import json
from datetime import datetime

@dataclass
class CitationInfo:
    """引用信息数据结构"""
    chunk_id: str
    source_file: str
    page_number: int
    start_position: int
    end_position: int
    chunk_text: str
    confidence_score: float
    retrieval_rank: int
    similarity_score: float
    
    def to_dict(self) -> Dict:
        """转换为字典格式"""
        return {
            'chunk_id': self.chunk_id,
            'source_file': self.source_file,
            'page_number': self.page_number,
            'start_position': self.start_position,
            'end_position': self.end_position,
            'chunk_text': self.chunk_text,
            'confidence_score': self.confidence_score,
            'retrieval_rank': self.retrieval_rank,
            'similarity_score': self.similarity_score
        }

class CitationTracker:
    """引用追踪器"""
    
    def __init__(self):
        self.citations: List[CitationInfo] = []
        self.citation_map: Dict[str, CitationInfo] = {}
    
    def add_citation(self, citation: CitationInfo):
        """添加引用信息"""
        self.citations.append(citation)
        self.citation_map[citation.chunk_id] = citation
    
    def get_citation(self, chunk_id: str) -> Optional[CitationInfo]:
        """获取指定的引用信息"""
        return self.citation_map.get(chunk_id)
    
    def get_top_citations(self, n: int = 5) -> List[CitationInfo]:
        """获取置信度最高的N个引用"""
        return sorted(self.citations, 
                     key=lambda x: x.confidence_score, 
                     reverse=True)[:n]
    
    def filter_by_confidence(self, threshold: float = 0.5) -> List[CitationInfo]:
        """根据置信度阈值过滤引用"""
        return [c for c in self.citations if c.confidence_score >= threshold]
```

### 步骤2：实现置信度计算模块（4分钟）

创建 `confidence_calculator.py` 文件：

```python
import math
from typing import Dict, Any

class ConfidenceCalculator:
    """置信度计算器"""
    
    def __init__(self, weights: Dict[str, float] = None):
        # 默认权重配置
        self.weights = weights or {
            'similarity_score': 0.3,
            'rerank_score': 0.5,
            'doc_quality': 0.2
        }
    
    def calculate_confidence(self, 
                           similarity_score: float,
                           rerank_score: float,
                           doc_quality: float = 0.5,
                           retrieval_rank: int = 1) -> float:
        """计算综合置信度"""
        
        # 1. 基础分数加权
        base_confidence = (
            similarity_score * self.weights['similarity_score'] +
            rerank_score * self.weights['rerank_score'] +
            doc_quality * self.weights['doc_quality']
        )
        
        # 2. 排名惩罚（排名越靠后，置信度越低）
        rank_penalty = 1.0 / (1.0 + math.log(retrieval_rank))
        
        # 3. 最终置信度
        final_confidence = base_confidence * rank_penalty
        
        return min(final_confidence, 1.0)
    
    def get_confidence_level(self, confidence: float) -> str:
        """获取置信度等级"""
        if confidence >= 0.8:
            return "高置信度"
        elif confidence >= 0.5:
            return "中等置信度"
        else:
            return "低置信度"
    
    def should_include_citation(self, confidence: float, threshold: float = 0.3) -> bool:
        """判断是否应该包含此引用"""
        return confidence >= threshold
```

### 步骤3：实现引用格式化工具（4分钟）

创建 `citation_formatter.py` 文件：

```python
from typing import List, Dict, Any
from citation_system import CitationInfo
import re

class CitationFormatter:
    """引用格式化工具"""
    
    def __init__(self, style: str = "numbered"):
        self.style = style  # numbered, author-year, footnote
        self.citation_counter = 0
    
    def format_inline_citation(self, citation: CitationInfo) -> str:
        """格式化内联引用"""
        if self.style == "numbered":
            self.citation_counter += 1
            return f"[{self.citation_counter}]"
        elif self.style == "author-year":
            # 简化版，实际应该从文档元数据中提取作者和年份
            return f"({citation.source_file}, p.{citation.page_number})"
        else:
            return f"[{citation.chunk_id}]"
    
    def format_citation_list(self, citations: List[CitationInfo]) -> str:
        """格式化引用列表"""
        citation_list = []
        
        for i, citation in enumerate(citations, 1):
            formatted_citation = self._format_single_citation(citation, i)
            citation_list.append(formatted_citation)
        
        return "\n".join(citation_list)
    
    def _format_single_citation(self, citation: CitationInfo, index: int) -> str:
        """格式化单个引用"""
        confidence_level = self._get_confidence_indicator(citation.confidence_score)
        
        return f"""[{index}] {citation.source_file}, 第{citation.page_number}页 {confidence_level}
    置信度: {citation.confidence_score:.2f}
    预览: {citation.chunk_text[:100]}..."""
    
    def _get_confidence_indicator(self, confidence: float) -> str:
        """获取置信度指示符"""
        if confidence >= 0.8:
            return "✓✓✓"
        elif confidence >= 0.5:
            return "✓✓"
        else:
            return "✓"
    
    def embed_citations_in_text(self, text: str, citations: List[CitationInfo]) -> str:
        """在文本中嵌入引用"""
        # 简化实现：在每个句子末尾添加相关引用
        sentences = re.split(r'[.!?]+', text)
        result_sentences = []
        
        for sentence in sentences:
            if sentence.strip():
                # 找到与句子最相关的引用
                relevant_citations = self._find_relevant_citations(sentence, citations)
                
                citation_marks = "".join([
                    self.format_inline_citation(c) for c in relevant_citations[:2]  # 最多2个引用
                ])
                
                result_sentences.append(sentence.strip() + citation_marks)
        
        return ". ".join(result_sentences) + "."
    
    def _find_relevant_citations(self, sentence: str, citations: List[CitationInfo]) -> List[CitationInfo]:
        """找到与句子相关的引用（简化实现）"""
        # 简化实现：返回置信度最高的引用
        return sorted(citations, key=lambda x: x.confidence_score, reverse=True)[:1]

class CitationRenderer:
    """引用渲染器 - 用于不同输出格式"""
    
    def render_html(self, text_with_citations: str, citation_list: str) -> str:
        """渲染HTML格式"""
        html_template = f"""
        <div class="answer-with-citations">
            <div class="answer-text">
                {text_with_citations}
            </div>
            <div class="citations">
                <h4>参考来源：</h4>
                <pre>{citation_list}</pre>
            </div>
        </div>
        """
        return html_template
    
    def render_markdown(self, text_with_citations: str, citation_list: str) -> str:
        """渲染Markdown格式"""
        return f"""
{text_with_citations}

## 参考来源

{citation_list}
        """
    
    def render_json(self, text: str, citations: List[CitationInfo]) -> Dict[str, Any]:
        """渲染JSON格式"""
        return {
            "answer": text,
            "citations": [c.to_dict() for c in citations],
            "citation_count": len(citations),
            "avg_confidence": sum(c.confidence_score for c in citations) / len(citations) if citations else 0
        }
```

### 步骤4：集成到RAG系统（3分钟）

修改你的主RAG系统，集成引用功能：

```python
# 在你的主RAG系统中添加以下代码

from citation_system import CitationTracker, CitationInfo
from confidence_calculator import ConfidenceCalculator
from citation_formatter import CitationFormatter, CitationRenderer

class RAGWithCitations:
    """带引用功能的RAG系统"""
    
    def __init__(self):
        self.citation_tracker = CitationTracker()
        self.confidence_calculator = ConfidenceCalculator()
        self.citation_formatter = CitationFormatter()
        self.citation_renderer = CitationRenderer()
        # ... 其他RAG组件初始化
    
    def query_with_citations(self, query: str) -> Dict[str, Any]:
        """带引用的查询"""
        # 1. 执行检索（使用你现有的检索逻辑）
        retrieval_results = self.retrieve_documents(query)  # 你的检索方法
        
        # 2. 重排序（使用你现有的重排序逻辑）
        reranked_results = self.rerank_documents(query, retrieval_results)  # 你的重排序方法
        
        # 3. 创建引用信息
        citations = []
        for rank, (doc, rerank_score) in enumerate(reranked_results[:5], 1):
            # 计算置信度
            confidence = self.confidence_calculator.calculate_confidence(
                similarity_score=doc.get('similarity_score', 0.5),
                rerank_score=rerank_score,
                doc_quality=doc.get('quality_score', 0.5),
                retrieval_rank=rank
            )
            
            # 创建引用信息
            citation = CitationInfo(
                chunk_id=doc['id'],
                source_file=doc['metadata']['source_file'],
                page_number=doc['metadata'].get('page_number', 1),
                start_position=doc['metadata'].get('start_pos', 0),
                end_position=doc['metadata'].get('end_pos', 0),
                chunk_text=doc['content'],
                confidence_score=confidence,
                retrieval_rank=rank,
                similarity_score=doc.get('similarity_score', 0.5)
            )
            
            citations.append(citation)
            self.citation_tracker.add_citation(citation)
        
        # 4. 生成答案（使用你现有的生成逻辑）
        answer = self.generate_answer(query, reranked_results)  # 你的生成方法
        
        # 5. 添加引用到答案中
        high_confidence_citations = self.citation_tracker.filter_by_confidence(0.5)
        answer_with_citations = self.citation_formatter.embed_citations_in_text(
            answer, high_confidence_citations
        )
        
        # 6. 格式化引用列表
        citation_list = self.citation_formatter.format_citation_list(high_confidence_citations)
        
        return {
            "answer": answer_with_citations,
            "citations": citation_list,
            "raw_citations": [c.to_dict() for c in high_confidence_citations],
            "total_citations": len(citations),
            "high_confidence_count": len(high_confidence_citations)
        }
```

### 步骤5：测试引用系统（1分钟）

创建 `test_citation.py` 文件：

```python
from citation_system import CitationInfo, CitationTracker
from confidence_calculator import ConfidenceCalculator
from citation_formatter import CitationFormatter, CitationRenderer

def test_citation_system():
    """测试引用系统"""
    
    # 创建测试数据
    citation1 = CitationInfo(
        chunk_id="chunk_001",
        source_file="AI技术发展报告.pdf",
        page_number=15,
        start_position=1200,
        end_position=1500,
        chunk_text="人工智能技术在近年来取得了显著进展，特别是在自然语言处理领域。大型语言模型的出现改变了整个行业的发展方向。",
        confidence_score=0.85,
        retrieval_rank=1,
        similarity_score=0.92
    )
    
    citation2 = CitationInfo(
        chunk_id="chunk_002",
        source_file="机器学习基础.docx",
        page_number=8,
        start_position=800,
        end_position=1100,
        chunk_text="检索增强生成（RAG）是一种结合了信息检索和文本生成的技术，能够提供更准确和可验证的答案。",
        confidence_score=0.72,
        retrieval_rank=2,
        similarity_score=0.78
    )
    
    # 测试引用追踪
    tracker = CitationTracker()
    tracker.add_citation(citation1)
    tracker.add_citation(citation2)
    
    print("=== 引用追踪测试 ===")
    print(f"总引用数: {len(tracker.citations)}")
    print(f"高置信度引用: {len(tracker.filter_by_confidence(0.8))}")
    
    # 测试置信度计算
    calculator = ConfidenceCalculator()
    new_confidence = calculator.calculate_confidence(
        similarity_score=0.85,
        rerank_score=0.90,
        doc_quality=0.75,
        retrieval_rank=1
    )
    print(f"\n=== 置信度计算测试 ===")
    print(f"计算得到的置信度: {new_confidence:.3f}")
    print(f"置信度等级: {calculator.get_confidence_level(new_confidence)}")
    
    # 测试引用格式化
    formatter = CitationFormatter()
    renderer = CitationRenderer()
    
    test_answer = "人工智能技术发展迅速。RAG技术提供了新的解决方案。"
    
    answer_with_citations = formatter.embed_citations_in_text(
        test_answer, [citation1, citation2]
    )
    citation_list = formatter.format_citation_list([citation1, citation2])
    
    print(f"\n=== 引用格式化测试 ===")
    print(f"带引用的答案: {answer_with_citations}")
    print(f"\n引用列表:\n{citation_list}")
    
    # 测试不同渲染格式
    print(f"\n=== 渲染格式测试 ===")
    markdown_output = renderer.render_markdown(answer_with_citations, citation_list)
    print("Markdown格式:")
    print(markdown_output)
    
    json_output = renderer.render_json(test_answer, [citation1, citation2])
    print(f"\nJSON格式: {json_output}")

if __name__ == "__main__":
    test_citation_system()
```

## 实验验证

运行测试脚本：
```bash
python test_citation.py
```

预期输出应该包括：
1. 引用信息的正确追踪
2. 置信度的准确计算
3. 引用的正确格式化
4. 不同格式的正确渲染

## 实验思考题

1. **引用质量评估**：如何评估引用的相关性和准确性？
2. **性能优化**：在大规模文档库中，如何优化引用追踪的性能？
3. **用户体验**：如何设计引用展示以平衡信息完整性和阅读体验？
4. **冲突处理**：当多个来源提供冲突信息时，如何处理引用？

## 扩展实验

如果时间允许，可以尝试：

1. **实现交互式引用查看**：点击引用标记显示详细信息
2. **添加引用相关性评分**：评估引用与答案的相关程度
3. **实现引用去重**：避免重复引用同一来源
4. **添加引用统计**：分析引用分布和质量指标

## 常见问题解决

### 问题1：引用信息丢失
**解决方案**：检查文档处理流程，确保元数据在每个阶段都被正确传递。

### 问题2：置信度计算不准确
**解决方案**：调整权重配置，根据实际效果优化计算公式。

### 问题3：引用格式显示异常
**解决方案**：检查文本编码和特殊字符处理。

## 实验总结

通过本实验，你应该掌握了：
1. 引用信息的数据结构设计
2. 置信度计算的多维度方法
3. 引用格式化和展示技术
4. 引用系统与RAG系统的集成方法

这些技能将帮助你构建更加可信和透明的RAG系统。