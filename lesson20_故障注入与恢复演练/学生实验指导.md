# Lesson 20 - æ•…éšœæ³¨å…¥ä¸æ¢å¤æ¼”ç»ƒ å®éªŒæŒ‡å¯¼

## ğŸ¯ å®éªŒç›®æ ‡

é€šè¿‡æœ¬æ¬¡å®éªŒï¼Œä½ å°†å­¦ä¼šï¼š

1. å®ç°æ•…éšœæ³¨å…¥æ¡†æ¶ï¼Œæ¨¡æ‹ŸçœŸå®çš„ç³»ç»Ÿæ•…éšœ
2. æ„å»ºè‡ªåŠ¨æ¢å¤æœºåˆ¶ï¼Œæå‡ç³»ç»Ÿå®¹é”™èƒ½åŠ›
3. å»ºç«‹ç›‘æ§å‘Šè­¦ä½“ç³»ï¼Œå®æ—¶è·Ÿè¸ªç³»ç»Ÿå¥åº·çŠ¶æ€
4. è¿›è¡Œæ•…éšœæ¢å¤æ¼”ç»ƒï¼ŒéªŒè¯ç³»ç»Ÿå¯é æ€§

## ğŸ› ï¸ å®éªŒç¯å¢ƒå‡†å¤‡

### å‰ç½®æ¡ä»¶

- å·²å®Œæˆå‰19èŠ‚è¯¾çš„RAGç³»ç»Ÿå¼€å‘
- Python 3.8+
- å·²å®‰è£…å¿…è¦çš„ä¾èµ–åŒ…

### ä¾èµ–å®‰è£…

```bash
pip install asyncio aiohttp tenacity prometheus-client
```

## ğŸ“‹ å®éªŒæ­¥éª¤

### æ­¥éª¤1ï¼šåˆ›å»ºæ•…éšœæ³¨å…¥æ¡†æ¶ï¼ˆ10åˆ†é’Ÿï¼‰

#### 1.1 åˆ›å»ºæ•…éšœæ³¨å…¥å™¨ç±»

åœ¨ `rag_system/fault_injection/` ç›®å½•ä¸‹åˆ›å»º `fault_injector.py`ï¼š

```python
import random
import time
import logging
from typing import Dict, Any, Optional
from enum import Enum

class FaultType(Enum):
    """æ•…éšœç±»å‹æšä¸¾"""
    NETWORK_TIMEOUT = "network_timeout"
    SERVICE_UNAVAILABLE = "service_unavailable"
    DATA_CORRUPTION = "data_corruption"
    RESOURCE_EXHAUSTION = "resource_exhaustion"
    RANDOM_ERROR = "random_error"

class FaultInjectionError(Exception):
    """æ•…éšœæ³¨å…¥å¼‚å¸¸"""
    def __init__(self, fault_type: FaultType, message: str):
        self.fault_type = fault_type
        self.message = message
        super().__init__(f"[{fault_type.value}] {message}")

class FaultInjector:
    """æ•…éšœæ³¨å…¥å™¨"""
    
    def __init__(self, failure_rate: float = 0.1, enabled: bool = True):
        """
        åˆå§‹åŒ–æ•…éšœæ³¨å…¥å™¨
        
        Args:
            failure_rate: æ•…éšœæ³¨å…¥æ¦‚ç‡ (0.0-1.0)
            enabled: æ˜¯å¦å¯ç”¨æ•…éšœæ³¨å…¥
        """
        self.failure_rate = failure_rate
        self.enabled = enabled
        self.fault_counts = {fault_type: 0 for fault_type in FaultType}
        self.logger = logging.getLogger(__name__)
    
    def should_inject_fault(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥æ³¨å…¥æ•…éšœ"""
        return self.enabled and random.random() < self.failure_rate
    
    def inject_fault(self, fault_type: FaultType = FaultType.RANDOM_ERROR, 
                    context: str = "") -> None:
        """æ³¨å…¥æŒ‡å®šç±»å‹çš„æ•…éšœ"""
        if not self.should_inject_fault():
            return
        
        self.fault_counts[fault_type] += 1
        self.logger.warning(f"Injecting fault: {fault_type.value} in {context}")
        
        if fault_type == FaultType.NETWORK_TIMEOUT:
            time.sleep(5)  # æ¨¡æ‹Ÿç½‘ç»œè¶…æ—¶
            raise FaultInjectionError(fault_type, "Network timeout occurred")
        
        elif fault_type == FaultType.SERVICE_UNAVAILABLE:
            raise FaultInjectionError(fault_type, "Service temporarily unavailable")
        
        elif fault_type == FaultType.DATA_CORRUPTION:
            raise FaultInjectionError(fault_type, "Data corruption detected")
        
        elif fault_type == FaultType.RESOURCE_EXHAUSTION:
            raise FaultInjectionError(fault_type, "System resources exhausted")
        
        else:
            raise FaultInjectionError(fault_type, "Random system error")
    
    def get_fault_statistics(self) -> Dict[str, int]:
        """è·å–æ•…éšœç»Ÿè®¡ä¿¡æ¯"""
        return {fault_type.value: count for fault_type, count in self.fault_counts.items()}
    
    def reset_statistics(self) -> None:
        """é‡ç½®æ•…éšœç»Ÿè®¡"""
        self.fault_counts = {fault_type: 0 for fault_type in FaultType}
    
    def configure(self, failure_rate: Optional[float] = None, 
                 enabled: Optional[bool] = None) -> None:
        """åŠ¨æ€é…ç½®æ•…éšœæ³¨å…¥å™¨"""
        if failure_rate is not None:
            self.failure_rate = max(0.0, min(1.0, failure_rate))
        if enabled is not None:
            self.enabled = enabled
        
        self.logger.info(f"Fault injector configured: rate={self.failure_rate}, enabled={self.enabled}")
```

#### 1.2 æµ‹è¯•æ•…éšœæ³¨å…¥å™¨

åˆ›å»ºæµ‹è¯•æ–‡ä»¶ `test_fault_injection.py`ï¼š

```python
import time
from fault_injector import FaultInjector, FaultType, FaultInjectionError

def test_fault_injection():
    """æµ‹è¯•æ•…éšœæ³¨å…¥åŠŸèƒ½"""
    # åˆ›å»ºæ•…éšœæ³¨å…¥å™¨ï¼Œè®¾ç½®è¾ƒé«˜çš„æ•…éšœç‡ä¾¿äºæµ‹è¯•
    injector = FaultInjector(failure_rate=0.5, enabled=True)
    
    success_count = 0
    failure_count = 0
    
    print("å¼€å§‹æ•…éšœæ³¨å…¥æµ‹è¯•...")
    
    for i in range(20):
        try:
            # æ¨¡æ‹Ÿä¸šåŠ¡æ“ä½œ
            injector.inject_fault(FaultType.SERVICE_UNAVAILABLE, f"operation_{i}")
            print(f"æ“ä½œ {i}: æˆåŠŸ")
            success_count += 1
            
        except FaultInjectionError as e:
            print(f"æ“ä½œ {i}: å¤±è´¥ - {e}")
            failure_count += 1
    
    print(f"\næµ‹è¯•ç»“æœ:")
    print(f"æˆåŠŸ: {success_count}, å¤±è´¥: {failure_count}")
    print(f"æ•…éšœç»Ÿè®¡: {injector.get_fault_statistics()}")

if __name__ == "__main__":
    test_fault_injection()
```

### æ­¥éª¤2ï¼šå®ç°è‡ªåŠ¨æ¢å¤æœºåˆ¶ï¼ˆ15åˆ†é’Ÿï¼‰

#### 2.1 åˆ›å»ºé‡è¯•è£…é¥°å™¨

åˆ›å»º `recovery/retry_mechanism.py`ï¼š

```python
import time
import logging
from functools import wraps
from typing import Callable, Any, Type, Tuple
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

class RetryConfig:
    """é‡è¯•é…ç½®"""
    def __init__(self, max_attempts: int = 3, base_delay: float = 1.0, 
                 max_delay: float = 60.0, exponential_base: int = 2):
        self.max_attempts = max_attempts
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.exponential_base = exponential_base

def retry_with_backoff(config: RetryConfig = None, 
                      exception_types: Tuple[Type[Exception], ...] = (Exception,)):
    """å¸¦æŒ‡æ•°é€€é¿çš„é‡è¯•è£…é¥°å™¨"""
    if config is None:
        config = RetryConfig()
    
    def decorator(func: Callable) -> Callable:
        @retry(
            stop=stop_after_attempt(config.max_attempts),
            wait=wait_exponential(
                multiplier=config.base_delay,
                max=config.max_delay,
                exp_base=config.exponential_base
            ),
            retry=retry_if_exception_type(exception_types),
            reraise=True
        )
        @wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        
        return wrapper
    return decorator

class CircuitBreaker:
    """ç†”æ–­å™¨å®ç°"""
    
    def __init__(self, failure_threshold: int = 5, timeout: float = 60.0):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
        self.logger = logging.getLogger(__name__)
    
    def call(self, func: Callable, *args, **kwargs) -> Any:
        """é€šè¿‡ç†”æ–­å™¨è°ƒç”¨å‡½æ•°"""
        if self.state == 'OPEN':
            if self._should_attempt_reset():
                self.state = 'HALF_OPEN'
                self.logger.info("Circuit breaker state: HALF_OPEN")
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        
        except Exception as e:
            self._on_failure()
            raise e
    
    def _should_attempt_reset(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥å°è¯•é‡ç½®ç†”æ–­å™¨"""
        return (self.last_failure_time and 
                time.time() - self.last_failure_time >= self.timeout)
    
    def _on_success(self) -> None:
        """æˆåŠŸæ—¶çš„å¤„ç†"""
        self.failure_count = 0
        if self.state == 'HALF_OPEN':
            self.state = 'CLOSED'
            self.logger.info("Circuit breaker state: CLOSED")
    
    def _on_failure(self) -> None:
        """å¤±è´¥æ—¶çš„å¤„ç†"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = 'OPEN'
            self.logger.warning("Circuit breaker state: OPEN")
```

#### 2.2 é›†æˆæ¢å¤æœºåˆ¶åˆ°RAGç³»ç»Ÿ

åˆ›å»º `recovery/resilient_rag.py`ï¼š

```python
import asyncio
import logging
from typing import List, Dict, Any
from ..fault_injection.fault_injector import FaultInjector, FaultType, FaultInjectionError
from .retry_mechanism import retry_with_backoff, RetryConfig, CircuitBreaker

class ResilientRAGSystem:
    """å…·æœ‰å®¹é”™èƒ½åŠ›çš„RAGç³»ç»Ÿ"""
    
    def __init__(self):
        self.fault_injector = FaultInjector(failure_rate=0.1)
        self.circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=30.0)
        self.retry_config = RetryConfig(max_attempts=3, base_delay=1.0)
        self.logger = logging.getLogger(__name__)
    
    @retry_with_backoff()
    async def search_documents(self, query: str) -> List[Dict[str, Any]]:
        """å¸¦é‡è¯•çš„æ–‡æ¡£æœç´¢"""
        try:
            # æ³¨å…¥æ•…éšœ
            self.fault_injector.inject_fault(
                FaultType.SERVICE_UNAVAILABLE, 
                "document_search"
            )
            
            # æ¨¡æ‹Ÿæ–‡æ¡£æœç´¢
            await asyncio.sleep(0.1)
            
            return [
                {"content": f"Document about {query}", "score": 0.95},
                {"content": f"Related info on {query}", "score": 0.87}
            ]
            
        except FaultInjectionError as e:
            self.logger.error(f"Document search failed: {e}")
            raise e
    
    async def generate_response(self, query: str, documents: List[Dict[str, Any]]) -> str:
        """å¸¦ç†”æ–­å™¨çš„å“åº”ç”Ÿæˆ"""
        def _generate():
            # æ³¨å…¥æ•…éšœ
            self.fault_injector.inject_fault(
                FaultType.NETWORK_TIMEOUT, 
                "response_generation"
            )
            
            # æ¨¡æ‹Ÿå“åº”ç”Ÿæˆ
            context = " ".join([doc["content"] for doc in documents])
            return f"Based on the context: {context}, the answer to '{query}' is..."
        
        try:
            return self.circuit_breaker.call(_generate)
        except Exception as e:
            self.logger.error(f"Response generation failed: {e}")
            # è¿”å›é™çº§å“åº”
            return f"Sorry, I'm having trouble generating a response for '{query}'. Please try again later."
    
    async def query(self, query: str) -> Dict[str, Any]:
        """å®Œæ•´çš„æŸ¥è¯¢æµç¨‹"""
        start_time = time.time()
        
        try:
            # æœç´¢æ–‡æ¡£
            documents = await self.search_documents(query)
            
            # ç”Ÿæˆå“åº”
            response = await self.generate_response(query, documents)
            
            return {
                "query": query,
                "response": response,
                "documents": documents,
                "success": True,
                "duration": time.time() - start_time
            }
            
        except Exception as e:
            self.logger.error(f"Query failed: {e}")
            return {
                "query": query,
                "response": "Sorry, the system is currently unavailable.",
                "documents": [],
                "success": False,
                "duration": time.time() - start_time,
                "error": str(e)
            }
```

### æ­¥éª¤3ï¼šå»ºç«‹ç›‘æ§å‘Šè­¦ç³»ç»Ÿï¼ˆ10åˆ†é’Ÿï¼‰

#### 3.1 åˆ›å»ºç›‘æ§æŒ‡æ ‡æ”¶é›†å™¨

åˆ›å»º `monitoring/metrics_collector.py`ï¼š

```python
import time
import threading
from typing import Dict, List, Any
from collections import defaultdict, deque
from dataclasses import dataclass

@dataclass
class MetricPoint:
    """æŒ‡æ ‡æ•°æ®ç‚¹"""
    timestamp: float
    value: float
    labels: Dict[str, str] = None

class MetricsCollector:
    """æŒ‡æ ‡æ”¶é›†å™¨"""
    
    def __init__(self, max_points: int = 1000):
        self.max_points = max_points
        self.metrics = defaultdict(lambda: deque(maxlen=max_points))
        self.counters = defaultdict(int)
        self.gauges = defaultdict(float)
        self.lock = threading.Lock()
    
    def increment_counter(self, name: str, value: int = 1, labels: Dict[str, str] = None):
        """å¢åŠ è®¡æ•°å™¨"""
        with self.lock:
            key = self._make_key(name, labels)
            self.counters[key] += value
    
    def set_gauge(self, name: str, value: float, labels: Dict[str, str] = None):
        """è®¾ç½®ä»ªè¡¨ç›˜å€¼"""
        with self.lock:
            key = self._make_key(name, labels)
            self.gauges[key] = value
    
    def record_histogram(self, name: str, value: float, labels: Dict[str, str] = None):
        """è®°å½•ç›´æ–¹å›¾æ•°æ®"""
        with self.lock:
            key = self._make_key(name, labels)
            point = MetricPoint(timestamp=time.time(), value=value, labels=labels)
            self.metrics[key].append(point)
    
    def get_counter(self, name: str, labels: Dict[str, str] = None) -> int:
        """è·å–è®¡æ•°å™¨å€¼"""
        key = self._make_key(name, labels)
        return self.counters.get(key, 0)
    
    def get_gauge(self, name: str, labels: Dict[str, str] = None) -> float:
        """è·å–ä»ªè¡¨ç›˜å€¼"""
        key = self._make_key(name, labels)
        return self.gauges.get(key, 0.0)
    
    def get_histogram_stats(self, name: str, labels: Dict[str, str] = None) -> Dict[str, float]:
        """è·å–ç›´æ–¹å›¾ç»Ÿè®¡ä¿¡æ¯"""
        key = self._make_key(name, labels)
        points = list(self.metrics.get(key, []))
        
        if not points:
            return {"count": 0, "avg": 0, "min": 0, "max": 0}
        
        values = [p.value for p in points]
        return {
            "count": len(values),
            "avg": sum(values) / len(values),
            "min": min(values),
            "max": max(values)
        }
    
    def _make_key(self, name: str, labels: Dict[str, str] = None) -> str:
        """ç”ŸæˆæŒ‡æ ‡é”®"""
        if not labels:
            return name
        label_str = ",".join([f"{k}={v}" for k, v in sorted(labels.items())])
        return f"{name}{{{label_str}}}"
    
    def get_all_metrics(self) -> Dict[str, Any]:
        """è·å–æ‰€æœ‰æŒ‡æ ‡"""
        with self.lock:
            return {
                "counters": dict(self.counters),
                "gauges": dict(self.gauges),
                "histograms": {name: self.get_histogram_stats(name.split("{")[0]) 
                             for name in self.metrics.keys()}
            }

class SystemMonitor:
    """ç³»ç»Ÿç›‘æ§å™¨"""
    
    def __init__(self):
        self.metrics = MetricsCollector()
        self.alert_thresholds = {
            "error_rate": 0.1,  # 10%é”™è¯¯ç‡
            "response_time": 5.0,  # 5ç§’å“åº”æ—¶é—´
            "circuit_breaker_open": 1  # ç†”æ–­å™¨å¼€å¯
        }
        self.alerts = []
    
    def record_request(self, success: bool, duration: float, operation: str = "query"):
        """è®°å½•è¯·æ±‚æŒ‡æ ‡"""
        # è®°å½•è¯·æ±‚è®¡æ•°
        self.metrics.increment_counter("requests_total", labels={"operation": operation})
        
        # è®°å½•æˆåŠŸ/å¤±è´¥
        status = "success" if success else "error"
        self.metrics.increment_counter("requests_by_status", 
                                     labels={"operation": operation, "status": status})
        
        # è®°å½•å“åº”æ—¶é—´
        self.metrics.record_histogram("response_time", duration, 
                                    labels={"operation": operation})
        
        # æ£€æŸ¥å‘Šè­¦
        self._check_alerts()
    
    def record_circuit_breaker_state(self, state: str, operation: str = "query"):
        """è®°å½•ç†”æ–­å™¨çŠ¶æ€"""
        self.metrics.set_gauge("circuit_breaker_state", 
                             1 if state == "OPEN" else 0,
                             labels={"operation": operation})
    
    def _check_alerts(self):
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        # æ£€æŸ¥é”™è¯¯ç‡
        total_requests = self.metrics.get_counter("requests_total")
        error_requests = self.metrics.get_counter("requests_by_status", 
                                                labels={"status": "error"})
        
        if total_requests > 0:
            error_rate = error_requests / total_requests
            if error_rate > self.alert_thresholds["error_rate"]:
                self._trigger_alert("HIGH_ERROR_RATE", 
                                  f"Error rate: {error_rate:.2%}")
        
        # æ£€æŸ¥å“åº”æ—¶é—´
        response_stats = self.metrics.get_histogram_stats("response_time")
        if response_stats["avg"] > self.alert_thresholds["response_time"]:
            self._trigger_alert("HIGH_RESPONSE_TIME", 
                              f"Average response time: {response_stats['avg']:.2f}s")
    
    def _trigger_alert(self, alert_type: str, message: str):
        """è§¦å‘å‘Šè­¦"""
        alert = {
            "type": alert_type,
            "message": message,
            "timestamp": time.time()
        }
        self.alerts.append(alert)
        print(f"ğŸš¨ ALERT: {alert_type} - {message}")
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """è·å–ç›‘æ§é¢æ¿æ•°æ®"""
        total_requests = self.metrics.get_counter("requests_total")
        error_requests = self.metrics.get_counter("requests_by_status", 
                                                labels={"status": "error"})
        success_requests = self.metrics.get_counter("requests_by_status", 
                                                  labels={"status": "success"})
        
        error_rate = error_requests / total_requests if total_requests > 0 else 0
        success_rate = success_requests / total_requests if total_requests > 0 else 0
        
        response_stats = self.metrics.get_histogram_stats("response_time")
        
        return {
            "total_requests": total_requests,
            "success_rate": success_rate,
            "error_rate": error_rate,
            "avg_response_time": response_stats["avg"],
            "recent_alerts": self.alerts[-10:],  # æœ€è¿‘10ä¸ªå‘Šè­¦
            "circuit_breaker_status": self.metrics.get_gauge("circuit_breaker_state")
        }
```

### æ­¥éª¤4ï¼šé›†æˆæµ‹è¯•å’Œæ¼”ç»ƒï¼ˆ10åˆ†é’Ÿï¼‰

#### 4.1 åˆ›å»ºç»¼åˆæµ‹è¯•è„šæœ¬

åˆ›å»º `test_resilience.py`ï¼š

```python
import asyncio
import time
from recovery.resilient_rag import ResilientRAGSystem
from monitoring.metrics_collector import SystemMonitor

async def run_resilience_test():
    """è¿è¡Œå¼¹æ€§æµ‹è¯•"""
    rag_system = ResilientRAGSystem()
    monitor = SystemMonitor()
    
    print("ğŸš€ å¼€å§‹å¼¹æ€§æµ‹è¯•...")
    print("=" * 50)
    
    # æµ‹è¯•æŸ¥è¯¢åˆ—è¡¨
    test_queries = [
        "ä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ï¼Ÿ",
        "å¦‚ä½•å®ç°RAGç³»ç»Ÿï¼Ÿ",
        "æ•…éšœæ³¨å…¥çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ",
        "å¦‚ä½•æé«˜ç³»ç»Ÿå¯é æ€§ï¼Ÿ",
        "ç›‘æ§ç³»ç»Ÿçš„é‡è¦æ€§"
    ]
    
    # æ‰§è¡Œå¤šè½®æµ‹è¯•
    for round_num in range(3):
        print(f"\nğŸ“Š ç¬¬ {round_num + 1} è½®æµ‹è¯•")
        print("-" * 30)
        
        for i, query in enumerate(test_queries):
            start_time = time.time()
            
            try:
                result = await rag_system.query(query)
                duration = time.time() - start_time
                
                # è®°å½•ç›‘æ§æŒ‡æ ‡
                monitor.record_request(result["success"], duration)
                
                status = "âœ…" if result["success"] else "âŒ"
                print(f"{status} æŸ¥è¯¢ {i+1}: {query[:20]}... ({duration:.2f}s)")
                
                if not result["success"]:
                    print(f"   é”™è¯¯: {result.get('error', 'Unknown error')}")
                
            except Exception as e:
                duration = time.time() - start_time
                monitor.record_request(False, duration)
                print(f"âŒ æŸ¥è¯¢ {i+1}: å¼‚å¸¸ - {e}")
            
            # è®°å½•ç†”æ–­å™¨çŠ¶æ€
            monitor.record_circuit_breaker_state(rag_system.circuit_breaker.state)
            
            # çŸ­æš‚å»¶è¿Ÿ
            await asyncio.sleep(0.5)
        
        # æ˜¾ç¤ºå½“å‰è½®æ¬¡ç»Ÿè®¡
        dashboard = monitor.get_dashboard_data()
        print(f"\nğŸ“ˆ å½“å‰ç»Ÿè®¡:")
        print(f"   æ€»è¯·æ±‚æ•°: {dashboard['total_requests']}")
        print(f"   æˆåŠŸç‡: {dashboard['success_rate']:.2%}")
        print(f"   é”™è¯¯ç‡: {dashboard['error_rate']:.2%}")
        print(f"   å¹³å‡å“åº”æ—¶é—´: {dashboard['avg_response_time']:.2f}s")
        
        # ç­‰å¾…ä¸€æ®µæ—¶é—´å†è¿›è¡Œä¸‹ä¸€è½®
        if round_num < 2:
            print("\nâ³ ç­‰å¾…10ç§’åè¿›è¡Œä¸‹ä¸€è½®æµ‹è¯•...")
            await asyncio.sleep(10)
    
    # æœ€ç»ˆæŠ¥å‘Š
    print("\n" + "=" * 50)
    print("ğŸ“‹ æœ€ç»ˆæµ‹è¯•æŠ¥å‘Š")
    print("=" * 50)
    
    final_dashboard = monitor.get_dashboard_data()
    print(f"æ€»è¯·æ±‚æ•°: {final_dashboard['total_requests']}")
    print(f"æˆåŠŸç‡: {final_dashboard['success_rate']:.2%}")
    print(f"é”™è¯¯ç‡: {final_dashboard['error_rate']:.2%}")
    print(f"å¹³å‡å“åº”æ—¶é—´: {final_dashboard['avg_response_time']:.2f}s")
    
    # æ˜¾ç¤ºæ•…éšœç»Ÿè®¡
    fault_stats = rag_system.fault_injector.get_fault_statistics()
    print(f"\nğŸ”§ æ•…éšœæ³¨å…¥ç»Ÿè®¡:")
    for fault_type, count in fault_stats.items():
        if count > 0:
            print(f"   {fault_type}: {count} æ¬¡")
    
    # æ˜¾ç¤ºå‘Šè­¦
    if final_dashboard['recent_alerts']:
        print(f"\nğŸš¨ å‘Šè­¦è®°å½•:")
        for alert in final_dashboard['recent_alerts']:
            alert_time = time.strftime('%H:%M:%S', time.localtime(alert['timestamp']))
            print(f"   [{alert_time}] {alert['type']}: {alert['message']}")
    else:
        print("\nâœ… æ— å‘Šè­¦è®°å½•")

if __name__ == "__main__":
    asyncio.run(run_resilience_test())
```

## ğŸ¯ å®éªŒä»»åŠ¡

### ä»»åŠ¡1ï¼šåŸºç¡€æ•…éšœæ³¨å…¥æµ‹è¯•

1. è¿è¡Œæ•…éšœæ³¨å…¥å™¨æµ‹è¯•ï¼Œè§‚å¯Ÿä¸åŒæ•…éšœç‡ä¸‹çš„ç³»ç»Ÿè¡Œä¸º
2. è°ƒæ•´æ•…éšœç‡ä»0.1åˆ°0.5ï¼Œè®°å½•æˆåŠŸç‡å˜åŒ–
3. æµ‹è¯•ä¸åŒç±»å‹çš„æ•…éšœæ³¨å…¥æ•ˆæœ

### ä»»åŠ¡2ï¼šæ¢å¤æœºåˆ¶éªŒè¯

1. æµ‹è¯•é‡è¯•æœºåˆ¶åœ¨ä¸åŒæ•…éšœåœºæ™¯ä¸‹çš„è¡¨ç°
2. éªŒè¯ç†”æ–­å™¨åœ¨è¿ç»­æ•…éšœæ—¶çš„ä¿æŠ¤ä½œç”¨
3. è§‚å¯Ÿç³»ç»Ÿä»æ•…éšœçŠ¶æ€æ¢å¤åˆ°æ­£å¸¸çŠ¶æ€çš„è¿‡ç¨‹

### ä»»åŠ¡3ï¼šç›‘æ§å‘Šè­¦æµ‹è¯•

1. è§¦å‘é«˜é”™è¯¯ç‡å‘Šè­¦ï¼Œè§‚å¯Ÿå‘Šè­¦æœºåˆ¶
2. æ¨¡æ‹Ÿé«˜å“åº”æ—¶é—´åœºæ™¯ï¼ŒéªŒè¯æ€§èƒ½å‘Šè­¦
3. åˆ†æç›‘æ§é¢æ¿æ•°æ®ï¼Œç†è§£ç³»ç»Ÿå¥åº·çŠ¶æ€

### ä»»åŠ¡4ï¼šç»¼åˆå¼¹æ€§æµ‹è¯•

1. è¿è¡Œå®Œæ•´çš„å¼¹æ€§æµ‹è¯•è„šæœ¬
2. åˆ†ææµ‹è¯•ç»“æœï¼Œè¯†åˆ«ç³»ç»Ÿè–„å¼±ç¯èŠ‚
3. è°ƒæ•´é…ç½®å‚æ•°ï¼Œä¼˜åŒ–ç³»ç»Ÿå¼¹æ€§è¡¨ç°

## ğŸ¤” æ€è€ƒé¢˜

1. **æ•…éšœæ³¨å…¥ç­–ç•¥**ï¼šå¦‚ä½•è®¾è®¡æ›´çœŸå®çš„æ•…éšœåœºæ™¯ï¼Ÿä¸åŒç±»å‹çš„æ•…éšœåº”è¯¥å¦‚ä½•æ¨¡æ‹Ÿï¼Ÿ

2. **æ¢å¤æœºåˆ¶ä¼˜åŒ–**ï¼šåœ¨ä»€ä¹ˆæƒ…å†µä¸‹åº”è¯¥ä½¿ç”¨é‡è¯•ï¼Ÿä»€ä¹ˆæƒ…å†µä¸‹åº”è¯¥ä½¿ç”¨ç†”æ–­å™¨ï¼Ÿ

3. **ç›‘æ§æŒ‡æ ‡é€‰æ‹©**ï¼šé™¤äº†æˆåŠŸç‡å’Œå“åº”æ—¶é—´ï¼Œè¿˜åº”è¯¥ç›‘æ§å“ªäº›æŒ‡æ ‡ï¼Ÿ

4. **å‘Šè­¦é˜ˆå€¼è®¾ç½®**ï¼šå¦‚ä½•ç¡®å®šåˆé€‚çš„å‘Šè­¦é˜ˆå€¼ï¼Ÿè¿‡é«˜æˆ–è¿‡ä½çš„é˜ˆå€¼ä¼šå¸¦æ¥ä»€ä¹ˆé—®é¢˜ï¼Ÿ

5. **ç”Ÿäº§ç¯å¢ƒåº”ç”¨**ï¼šå¦‚ä½•åœ¨ç”Ÿäº§ç¯å¢ƒä¸­å®‰å…¨åœ°è¿›è¡Œæ•…éšœæ³¨å…¥æµ‹è¯•ï¼Ÿ

## ğŸ“ å®éªŒæŠ¥å‘Šè¦æ±‚

è¯·å®Œæˆå®éªŒåï¼Œæäº¤åŒ…å«ä»¥ä¸‹å†…å®¹çš„å®éªŒæŠ¥å‘Šï¼š

1. **å®éªŒè¿‡ç¨‹è®°å½•**ï¼šè¯¦ç»†è®°å½•æ¯ä¸ªæ­¥éª¤çš„æ‰§è¡Œè¿‡ç¨‹å’Œç»“æœ
2. **æ•…éšœæ³¨å…¥åˆ†æ**ï¼šåˆ†æä¸åŒæ•…éšœç±»å‹å¯¹ç³»ç»Ÿçš„å½±å“
3. **æ¢å¤æœºåˆ¶è¯„ä¼°**ï¼šè¯„ä¼°é‡è¯•å’Œç†”æ–­å™¨æœºåˆ¶çš„æœ‰æ•ˆæ€§
4. **ç›‘æ§æ•°æ®åˆ†æ**ï¼šåˆ†æç›‘æ§æŒ‡æ ‡çš„å˜åŒ–è¶‹åŠ¿
5. **ç³»ç»Ÿä¼˜åŒ–å»ºè®®**ï¼šåŸºäºå®éªŒç»“æœæå‡ºç³»ç»Ÿæ”¹è¿›å»ºè®®

## ğŸ”— æ‰©å±•å®éªŒ

å¦‚æœæ—¶é—´å…è®¸ï¼Œå¯ä»¥å°è¯•ä»¥ä¸‹æ‰©å±•å®éªŒï¼š

1. **è‡ªå®šä¹‰æ•…éšœç±»å‹**ï¼šå®ç°æ›´å¤šç±»å‹çš„æ•…éšœæ³¨å…¥
2. **æ™ºèƒ½æ¢å¤ç­–ç•¥**ï¼šåŸºäºæ•…éšœç±»å‹é€‰æ‹©ä¸åŒçš„æ¢å¤ç­–ç•¥
3. **åˆ†å¸ƒå¼æ•…éšœæ¨¡æ‹Ÿ**ï¼šæ¨¡æ‹Ÿåˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„æ•…éšœä¼ æ’­
4. **æ€§èƒ½åŸºå‡†æµ‹è¯•**ï¼šå¯¹æ¯”å¯ç”¨å’Œç¦ç”¨å®¹é”™æœºåˆ¶çš„æ€§èƒ½å·®å¼‚

---

**å®éªŒæ—¶é•¿**ï¼š45åˆ†é’Ÿ  
**éš¾åº¦ç­‰çº§**ï¼šä¸­çº§  
**å®Œæˆæ ‡å‡†**ï¼šæˆåŠŸè¿è¡Œæ‰€æœ‰æµ‹è¯•è„šæœ¬ï¼Œç†è§£æ•…éšœæ³¨å…¥å’Œæ¢å¤æœºåˆ¶çš„å·¥ä½œåŸç†