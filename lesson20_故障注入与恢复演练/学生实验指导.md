# Lesson 20 - 故障注入与恢复演练 实验指导

## 🎯 实验目标

通过本次实验，你将学会：

1. 实现故障注入框架，模拟真实的系统故障
2. 构建自动恢复机制，提升系统容错能力
3. 建立监控告警体系，实时跟踪系统健康状态
4. 进行故障恢复演练，验证系统可靠性

## 🛠️ 实验环境准备

### 前置条件

- 已完成前19节课的RAG系统开发
- Python 3.8+
- 已安装必要的依赖包

### 依赖安装

```bash
pip install asyncio aiohttp tenacity prometheus-client
```

## 📋 实验步骤

### 步骤1：创建故障注入框架（10分钟）

#### 1.1 创建故障注入器类

在 `rag_system/fault_injection/` 目录下创建 `fault_injector.py`：

```python
import random
import time
import logging
from typing import Dict, Any, Optional
from enum import Enum

class FaultType(Enum):
    """故障类型枚举"""
    NETWORK_TIMEOUT = "network_timeout"
    SERVICE_UNAVAILABLE = "service_unavailable"
    DATA_CORRUPTION = "data_corruption"
    RESOURCE_EXHAUSTION = "resource_exhaustion"
    RANDOM_ERROR = "random_error"

class FaultInjectionError(Exception):
    """故障注入异常"""
    def __init__(self, fault_type: FaultType, message: str):
        self.fault_type = fault_type
        self.message = message
        super().__init__(f"[{fault_type.value}] {message}")

class FaultInjector:
    """故障注入器"""
    
    def __init__(self, failure_rate: float = 0.1, enabled: bool = True):
        """
        初始化故障注入器
        
        Args:
            failure_rate: 故障注入概率 (0.0-1.0)
            enabled: 是否启用故障注入
        """
        self.failure_rate = failure_rate
        self.enabled = enabled
        self.fault_counts = {fault_type: 0 for fault_type in FaultType}
        self.logger = logging.getLogger(__name__)
    
    def should_inject_fault(self) -> bool:
        """判断是否应该注入故障"""
        return self.enabled and random.random() < self.failure_rate
    
    def inject_fault(self, fault_type: FaultType = FaultType.RANDOM_ERROR, 
                    context: str = "") -> None:
        """注入指定类型的故障"""
        if not self.should_inject_fault():
            return
        
        self.fault_counts[fault_type] += 1
        self.logger.warning(f"Injecting fault: {fault_type.value} in {context}")
        
        if fault_type == FaultType.NETWORK_TIMEOUT:
            time.sleep(5)  # 模拟网络超时
            raise FaultInjectionError(fault_type, "Network timeout occurred")
        
        elif fault_type == FaultType.SERVICE_UNAVAILABLE:
            raise FaultInjectionError(fault_type, "Service temporarily unavailable")
        
        elif fault_type == FaultType.DATA_CORRUPTION:
            raise FaultInjectionError(fault_type, "Data corruption detected")
        
        elif fault_type == FaultType.RESOURCE_EXHAUSTION:
            raise FaultInjectionError(fault_type, "System resources exhausted")
        
        else:
            raise FaultInjectionError(fault_type, "Random system error")
    
    def get_fault_statistics(self) -> Dict[str, int]:
        """获取故障统计信息"""
        return {fault_type.value: count for fault_type, count in self.fault_counts.items()}
    
    def reset_statistics(self) -> None:
        """重置故障统计"""
        self.fault_counts = {fault_type: 0 for fault_type in FaultType}
    
    def configure(self, failure_rate: Optional[float] = None, 
                 enabled: Optional[bool] = None) -> None:
        """动态配置故障注入器"""
        if failure_rate is not None:
            self.failure_rate = max(0.0, min(1.0, failure_rate))
        if enabled is not None:
            self.enabled = enabled
        
        self.logger.info(f"Fault injector configured: rate={self.failure_rate}, enabled={self.enabled}")
```

#### 1.2 测试故障注入器

创建测试文件 `test_fault_injection.py`：

```python
import time
from fault_injector import FaultInjector, FaultType, FaultInjectionError

def test_fault_injection():
    """测试故障注入功能"""
    # 创建故障注入器，设置较高的故障率便于测试
    injector = FaultInjector(failure_rate=0.5, enabled=True)
    
    success_count = 0
    failure_count = 0
    
    print("开始故障注入测试...")
    
    for i in range(20):
        try:
            # 模拟业务操作
            injector.inject_fault(FaultType.SERVICE_UNAVAILABLE, f"operation_{i}")
            print(f"操作 {i}: 成功")
            success_count += 1
            
        except FaultInjectionError as e:
            print(f"操作 {i}: 失败 - {e}")
            failure_count += 1
    
    print(f"\n测试结果:")
    print(f"成功: {success_count}, 失败: {failure_count}")
    print(f"故障统计: {injector.get_fault_statistics()}")

if __name__ == "__main__":
    test_fault_injection()
```

### 步骤2：实现自动恢复机制（15分钟）

#### 2.1 创建重试装饰器

创建 `recovery/retry_mechanism.py`：

```python
import time
import logging
from functools import wraps
from typing import Callable, Any, Type, Tuple
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type

class RetryConfig:
    """重试配置"""
    def __init__(self, max_attempts: int = 3, base_delay: float = 1.0, 
                 max_delay: float = 60.0, exponential_base: int = 2):
        self.max_attempts = max_attempts
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.exponential_base = exponential_base

def retry_with_backoff(config: RetryConfig = None, 
                      exception_types: Tuple[Type[Exception], ...] = (Exception,)):
    """带指数退避的重试装饰器"""
    if config is None:
        config = RetryConfig()
    
    def decorator(func: Callable) -> Callable:
        @retry(
            stop=stop_after_attempt(config.max_attempts),
            wait=wait_exponential(
                multiplier=config.base_delay,
                max=config.max_delay,
                exp_base=config.exponential_base
            ),
            retry=retry_if_exception_type(exception_types),
            reraise=True
        )
        @wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        
        return wrapper
    return decorator

class CircuitBreaker:
    """熔断器实现"""
    
    def __init__(self, failure_threshold: int = 5, timeout: float = 60.0):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
        self.logger = logging.getLogger(__name__)
    
    def call(self, func: Callable, *args, **kwargs) -> Any:
        """通过熔断器调用函数"""
        if self.state == 'OPEN':
            if self._should_attempt_reset():
                self.state = 'HALF_OPEN'
                self.logger.info("Circuit breaker state: HALF_OPEN")
            else:
                raise Exception("Circuit breaker is OPEN")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        
        except Exception as e:
            self._on_failure()
            raise e
    
    def _should_attempt_reset(self) -> bool:
        """判断是否应该尝试重置熔断器"""
        return (self.last_failure_time and 
                time.time() - self.last_failure_time >= self.timeout)
    
    def _on_success(self) -> None:
        """成功时的处理"""
        self.failure_count = 0
        if self.state == 'HALF_OPEN':
            self.state = 'CLOSED'
            self.logger.info("Circuit breaker state: CLOSED")
    
    def _on_failure(self) -> None:
        """失败时的处理"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = 'OPEN'
            self.logger.warning("Circuit breaker state: OPEN")
```

#### 2.2 集成恢复机制到RAG系统

创建 `recovery/resilient_rag.py`：

```python
import asyncio
import logging
from typing import List, Dict, Any
from ..fault_injection.fault_injector import FaultInjector, FaultType, FaultInjectionError
from .retry_mechanism import retry_with_backoff, RetryConfig, CircuitBreaker

class ResilientRAGSystem:
    """具有容错能力的RAG系统"""
    
    def __init__(self):
        self.fault_injector = FaultInjector(failure_rate=0.1)
        self.circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=30.0)
        self.retry_config = RetryConfig(max_attempts=3, base_delay=1.0)
        self.logger = logging.getLogger(__name__)
    
    @retry_with_backoff()
    async def search_documents(self, query: str) -> List[Dict[str, Any]]:
        """带重试的文档搜索"""
        try:
            # 注入故障
            self.fault_injector.inject_fault(
                FaultType.SERVICE_UNAVAILABLE, 
                "document_search"
            )
            
            # 模拟文档搜索
            await asyncio.sleep(0.1)
            
            return [
                {"content": f"Document about {query}", "score": 0.95},
                {"content": f"Related info on {query}", "score": 0.87}
            ]
            
        except FaultInjectionError as e:
            self.logger.error(f"Document search failed: {e}")
            raise e
    
    async def generate_response(self, query: str, documents: List[Dict[str, Any]]) -> str:
        """带熔断器的响应生成"""
        def _generate():
            # 注入故障
            self.fault_injector.inject_fault(
                FaultType.NETWORK_TIMEOUT, 
                "response_generation"
            )
            
            # 模拟响应生成
            context = " ".join([doc["content"] for doc in documents])
            return f"Based on the context: {context}, the answer to '{query}' is..."
        
        try:
            return self.circuit_breaker.call(_generate)
        except Exception as e:
            self.logger.error(f"Response generation failed: {e}")
            # 返回降级响应
            return f"Sorry, I'm having trouble generating a response for '{query}'. Please try again later."
    
    async def query(self, query: str) -> Dict[str, Any]:
        """完整的查询流程"""
        start_time = time.time()
        
        try:
            # 搜索文档
            documents = await self.search_documents(query)
            
            # 生成响应
            response = await self.generate_response(query, documents)
            
            return {
                "query": query,
                "response": response,
                "documents": documents,
                "success": True,
                "duration": time.time() - start_time
            }
            
        except Exception as e:
            self.logger.error(f"Query failed: {e}")
            return {
                "query": query,
                "response": "Sorry, the system is currently unavailable.",
                "documents": [],
                "success": False,
                "duration": time.time() - start_time,
                "error": str(e)
            }
```

### 步骤3：建立监控告警系统（10分钟）

#### 3.1 创建监控指标收集器

创建 `monitoring/metrics_collector.py`：

```python
import time
import threading
from typing import Dict, List, Any
from collections import defaultdict, deque
from dataclasses import dataclass

@dataclass
class MetricPoint:
    """指标数据点"""
    timestamp: float
    value: float
    labels: Dict[str, str] = None

class MetricsCollector:
    """指标收集器"""
    
    def __init__(self, max_points: int = 1000):
        self.max_points = max_points
        self.metrics = defaultdict(lambda: deque(maxlen=max_points))
        self.counters = defaultdict(int)
        self.gauges = defaultdict(float)
        self.lock = threading.Lock()
    
    def increment_counter(self, name: str, value: int = 1, labels: Dict[str, str] = None):
        """增加计数器"""
        with self.lock:
            key = self._make_key(name, labels)
            self.counters[key] += value
    
    def set_gauge(self, name: str, value: float, labels: Dict[str, str] = None):
        """设置仪表盘值"""
        with self.lock:
            key = self._make_key(name, labels)
            self.gauges[key] = value
    
    def record_histogram(self, name: str, value: float, labels: Dict[str, str] = None):
        """记录直方图数据"""
        with self.lock:
            key = self._make_key(name, labels)
            point = MetricPoint(timestamp=time.time(), value=value, labels=labels)
            self.metrics[key].append(point)
    
    def get_counter(self, name: str, labels: Dict[str, str] = None) -> int:
        """获取计数器值"""
        key = self._make_key(name, labels)
        return self.counters.get(key, 0)
    
    def get_gauge(self, name: str, labels: Dict[str, str] = None) -> float:
        """获取仪表盘值"""
        key = self._make_key(name, labels)
        return self.gauges.get(key, 0.0)
    
    def get_histogram_stats(self, name: str, labels: Dict[str, str] = None) -> Dict[str, float]:
        """获取直方图统计信息"""
        key = self._make_key(name, labels)
        points = list(self.metrics.get(key, []))
        
        if not points:
            return {"count": 0, "avg": 0, "min": 0, "max": 0}
        
        values = [p.value for p in points]
        return {
            "count": len(values),
            "avg": sum(values) / len(values),
            "min": min(values),
            "max": max(values)
        }
    
    def _make_key(self, name: str, labels: Dict[str, str] = None) -> str:
        """生成指标键"""
        if not labels:
            return name
        label_str = ",".join([f"{k}={v}" for k, v in sorted(labels.items())])
        return f"{name}{{{label_str}}}"
    
    def get_all_metrics(self) -> Dict[str, Any]:
        """获取所有指标"""
        with self.lock:
            return {
                "counters": dict(self.counters),
                "gauges": dict(self.gauges),
                "histograms": {name: self.get_histogram_stats(name.split("{")[0]) 
                             for name in self.metrics.keys()}
            }

class SystemMonitor:
    """系统监控器"""
    
    def __init__(self):
        self.metrics = MetricsCollector()
        self.alert_thresholds = {
            "error_rate": 0.1,  # 10%错误率
            "response_time": 5.0,  # 5秒响应时间
            "circuit_breaker_open": 1  # 熔断器开启
        }
        self.alerts = []
    
    def record_request(self, success: bool, duration: float, operation: str = "query"):
        """记录请求指标"""
        # 记录请求计数
        self.metrics.increment_counter("requests_total", labels={"operation": operation})
        
        # 记录成功/失败
        status = "success" if success else "error"
        self.metrics.increment_counter("requests_by_status", 
                                     labels={"operation": operation, "status": status})
        
        # 记录响应时间
        self.metrics.record_histogram("response_time", duration, 
                                    labels={"operation": operation})
        
        # 检查告警
        self._check_alerts()
    
    def record_circuit_breaker_state(self, state: str, operation: str = "query"):
        """记录熔断器状态"""
        self.metrics.set_gauge("circuit_breaker_state", 
                             1 if state == "OPEN" else 0,
                             labels={"operation": operation})
    
    def _check_alerts(self):
        """检查告警条件"""
        # 检查错误率
        total_requests = self.metrics.get_counter("requests_total")
        error_requests = self.metrics.get_counter("requests_by_status", 
                                                labels={"status": "error"})
        
        if total_requests > 0:
            error_rate = error_requests / total_requests
            if error_rate > self.alert_thresholds["error_rate"]:
                self._trigger_alert("HIGH_ERROR_RATE", 
                                  f"Error rate: {error_rate:.2%}")
        
        # 检查响应时间
        response_stats = self.metrics.get_histogram_stats("response_time")
        if response_stats["avg"] > self.alert_thresholds["response_time"]:
            self._trigger_alert("HIGH_RESPONSE_TIME", 
                              f"Average response time: {response_stats['avg']:.2f}s")
    
    def _trigger_alert(self, alert_type: str, message: str):
        """触发告警"""
        alert = {
            "type": alert_type,
            "message": message,
            "timestamp": time.time()
        }
        self.alerts.append(alert)
        print(f"🚨 ALERT: {alert_type} - {message}")
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """获取监控面板数据"""
        total_requests = self.metrics.get_counter("requests_total")
        error_requests = self.metrics.get_counter("requests_by_status", 
                                                labels={"status": "error"})
        success_requests = self.metrics.get_counter("requests_by_status", 
                                                  labels={"status": "success"})
        
        error_rate = error_requests / total_requests if total_requests > 0 else 0
        success_rate = success_requests / total_requests if total_requests > 0 else 0
        
        response_stats = self.metrics.get_histogram_stats("response_time")
        
        return {
            "total_requests": total_requests,
            "success_rate": success_rate,
            "error_rate": error_rate,
            "avg_response_time": response_stats["avg"],
            "recent_alerts": self.alerts[-10:],  # 最近10个告警
            "circuit_breaker_status": self.metrics.get_gauge("circuit_breaker_state")
        }
```

### 步骤4：集成测试和演练（10分钟）

#### 4.1 创建综合测试脚本

创建 `test_resilience.py`：

```python
import asyncio
import time
from recovery.resilient_rag import ResilientRAGSystem
from monitoring.metrics_collector import SystemMonitor

async def run_resilience_test():
    """运行弹性测试"""
    rag_system = ResilientRAGSystem()
    monitor = SystemMonitor()
    
    print("🚀 开始弹性测试...")
    print("=" * 50)
    
    # 测试查询列表
    test_queries = [
        "什么是机器学习？",
        "如何实现RAG系统？",
        "故障注入的作用是什么？",
        "如何提高系统可靠性？",
        "监控系统的重要性"
    ]
    
    # 执行多轮测试
    for round_num in range(3):
        print(f"\n📊 第 {round_num + 1} 轮测试")
        print("-" * 30)
        
        for i, query in enumerate(test_queries):
            start_time = time.time()
            
            try:
                result = await rag_system.query(query)
                duration = time.time() - start_time
                
                # 记录监控指标
                monitor.record_request(result["success"], duration)
                
                status = "✅" if result["success"] else "❌"
                print(f"{status} 查询 {i+1}: {query[:20]}... ({duration:.2f}s)")
                
                if not result["success"]:
                    print(f"   错误: {result.get('error', 'Unknown error')}")
                
            except Exception as e:
                duration = time.time() - start_time
                monitor.record_request(False, duration)
                print(f"❌ 查询 {i+1}: 异常 - {e}")
            
            # 记录熔断器状态
            monitor.record_circuit_breaker_state(rag_system.circuit_breaker.state)
            
            # 短暂延迟
            await asyncio.sleep(0.5)
        
        # 显示当前轮次统计
        dashboard = monitor.get_dashboard_data()
        print(f"\n📈 当前统计:")
        print(f"   总请求数: {dashboard['total_requests']}")
        print(f"   成功率: {dashboard['success_rate']:.2%}")
        print(f"   错误率: {dashboard['error_rate']:.2%}")
        print(f"   平均响应时间: {dashboard['avg_response_time']:.2f}s")
        
        # 等待一段时间再进行下一轮
        if round_num < 2:
            print("\n⏳ 等待10秒后进行下一轮测试...")
            await asyncio.sleep(10)
    
    # 最终报告
    print("\n" + "=" * 50)
    print("📋 最终测试报告")
    print("=" * 50)
    
    final_dashboard = monitor.get_dashboard_data()
    print(f"总请求数: {final_dashboard['total_requests']}")
    print(f"成功率: {final_dashboard['success_rate']:.2%}")
    print(f"错误率: {final_dashboard['error_rate']:.2%}")
    print(f"平均响应时间: {final_dashboard['avg_response_time']:.2f}s")
    
    # 显示故障统计
    fault_stats = rag_system.fault_injector.get_fault_statistics()
    print(f"\n🔧 故障注入统计:")
    for fault_type, count in fault_stats.items():
        if count > 0:
            print(f"   {fault_type}: {count} 次")
    
    # 显示告警
    if final_dashboard['recent_alerts']:
        print(f"\n🚨 告警记录:")
        for alert in final_dashboard['recent_alerts']:
            alert_time = time.strftime('%H:%M:%S', time.localtime(alert['timestamp']))
            print(f"   [{alert_time}] {alert['type']}: {alert['message']}")
    else:
        print("\n✅ 无告警记录")

if __name__ == "__main__":
    asyncio.run(run_resilience_test())
```

## 🎯 实验任务

### 任务1：基础故障注入测试

1. 运行故障注入器测试，观察不同故障率下的系统行为
2. 调整故障率从0.1到0.5，记录成功率变化
3. 测试不同类型的故障注入效果

### 任务2：恢复机制验证

1. 测试重试机制在不同故障场景下的表现
2. 验证熔断器在连续故障时的保护作用
3. 观察系统从故障状态恢复到正常状态的过程

### 任务3：监控告警测试

1. 触发高错误率告警，观察告警机制
2. 模拟高响应时间场景，验证性能告警
3. 分析监控面板数据，理解系统健康状态

### 任务4：综合弹性测试

1. 运行完整的弹性测试脚本
2. 分析测试结果，识别系统薄弱环节
3. 调整配置参数，优化系统弹性表现

## 🤔 思考题

1. **故障注入策略**：如何设计更真实的故障场景？不同类型的故障应该如何模拟？

2. **恢复机制优化**：在什么情况下应该使用重试？什么情况下应该使用熔断器？

3. **监控指标选择**：除了成功率和响应时间，还应该监控哪些指标？

4. **告警阈值设置**：如何确定合适的告警阈值？过高或过低的阈值会带来什么问题？

5. **生产环境应用**：如何在生产环境中安全地进行故障注入测试？

## 📝 实验报告要求

请完成实验后，提交包含以下内容的实验报告：

1. **实验过程记录**：详细记录每个步骤的执行过程和结果
2. **故障注入分析**：分析不同故障类型对系统的影响
3. **恢复机制评估**：评估重试和熔断器机制的有效性
4. **监控数据分析**：分析监控指标的变化趋势
5. **系统优化建议**：基于实验结果提出系统改进建议

## 🔗 扩展实验

如果时间允许，可以尝试以下扩展实验：

1. **自定义故障类型**：实现更多类型的故障注入
2. **智能恢复策略**：基于故障类型选择不同的恢复策略
3. **分布式故障模拟**：模拟分布式系统中的故障传播
4. **性能基准测试**：对比启用和禁用容错机制的性能差异

---

**实验时长**：45分钟  
**难度等级**：中级  
**完成标准**：成功运行所有测试脚本，理解故障注入和恢复机制的工作原理