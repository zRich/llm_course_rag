# 实验 3 操作手册（缓存策略）

本手册覆盖实验 3 的所有功能点：通用缓存模块、分层 TTL 配置、Embedding/检索/Rerank/QA 各层缓存接入、预热脚本与命中率采集、运行与验证指令。

### 1. 功能概览
- 通用缓存模块：支持 `memory` 与 `redis`，统一 `get_or_set` 接口、稳定键 `make_key`、TTL 抖动 `with_jitter`。
- 分层 TTL：Embedding/检索/Rerank/QA 层分别配置独立 TTL，支持抖动比避免雪崩。
- Embedding 缓存：按 `provider+model+normalized_text` 键缓存 embedding 结果。
- 检索缓存（Retrieval）：按 `query+limit+score_threshold+document_ids+model` 键缓存检索结果。
- 重排缓存（Rerank）：按候选集合摘要与模型键缓存重排结果。
- QA 缓存：按 `query+context_hash+prompt_style+llm_model` 键缓存答案结果。
- 预热脚本与命中率采集：提供预热思路与命中率日志打点方案。

### 2. 环境准备
- Python：建议 `Python 3.10+`
- 依赖安装：在项目根目录执行 `pip install -r requirements.txt`
- Redis（可选）：如启用 `redis` 提供者，先启动服务
  - `docker run -p 6379:6379 --name rag-redis -d redis:7`
- 进入实验 3 目录（代码位于 full 版）：`cd labs/full/lab03`

### 3. 配置说明
在 `labs/full/lab03/src/config/settings.py` 中新增（或通过环境变量覆盖）以下配置项：
- `cache_enabled`：是否启用缓存（默认 `True`）
- `cache_provider`：缓存提供者（`memory` 或 `redis`，默认 `memory`）
- `cache_namespace`：命名空间（默认 `lab03`）
- `cache_jitter_ratio`：TTL 抖动比例（默认 `0.1`）
- `cache_ttl_embedding`：Embedding 层 TTL（默认 `86400`）
- `cache_ttl_retrieval`：检索层 TTL（默认 `600`）
- `cache_ttl_rerank`：重排层 TTL（默认 `300`）
- `cache_ttl_qa`：QA 层 TTL（默认 `300`）

环境变量示例（可在 shell 中导出）：
```
export CACHE_ENABLED=true
export CACHE_PROVIDER=redis
export CACHE_NAMESPACE=lab03
export CACHE_JITTER_RATIO=0.1
export CACHE_TTL_EMBEDDING=86400
export CACHE_TTL_RETRIEVAL=600
export CACHE_TTL_RERANK=300
export CACHE_TTL_QA=300
```

如使用 Redis，确保连接参数（如 `REDIS_URL` 或 `REDIS_HOST/PORT` 等）在 `settings.py` 或环境变量中配置正确。

### 4. 服务启动
- 切换到服务目录：`cd labs/full/lab03/src`
- 启动 API：`uvicorn main:app --reload`
- 访问文档：`http://localhost:8000/docs`

### 5. 操作与验证步骤

#### 5.1 Embedding 缓存验证
方式 A：通过 Python 直接调用
```
cd labs/full/lab03/src
python -c "from services.embedding_service import EmbeddingService; s=EmbeddingService(); print(s.get_embedding('你好世界')[1])"
```
- 首次调用日志应出现 `cache_miss`，再次调用同样输入应出现 `cache_hit`。

方式 B：通过检索接口间接验证（会触发查询向量化）
```
curl -s "http://localhost:8000/api/v1/retrieval/hybrid_search?query=缓存策略&limit=10" | jq
```
- 第二次相同请求应更快，日志显示命中（embedding 与检索均可命中）。

#### 5.2 检索（Retrieval）缓存验证
```
curl -s "http://localhost:8000/api/v1/retrieval/hybrid_search?query=RAG系统&limit=10&score_threshold=0.2" | jq
```
- 重复相同参数调用观察命中日志 `cache_hit retrieval`，更换 `limit/score_threshold/document_ids` 任一参数应视为不同键。

#### 5.3 重排（Rerank）缓存验证
若检索结果启用重排：
```
curl -s "http://localhost:8000/api/v1/retrieval/hybrid_search?query=设计文档&limit=20&rerank=true" | jq
```
- 相同候选集合在短时间内重复请求应命中 `cache_hit rerank`。

#### 5.4 QA 缓存验证
```
curl -s -X POST "http://localhost:8000/api/v1/qa/ask" \
  -H "Content-Type: application/json" \
  -d '{"question":"请概述缓存策略设计要点","document_ids":[]}' | jq
```
- 相同 `question+context+prompt_style` 组合在短时间内重复请求应命中 `cache_hit qa`。

### 6. 预热与命中率采集

#### 6.1 预热（建议）
- 将常见问句与高频文档片段整理为列表，对 Embedding 与检索进行批量调用，提前写入缓存。
- 可在 `labs/full/lab03/src/scripts/` 下新增 `warmup_cache.py` 脚本（示例结构）：
```
# 伪代码
queries = ["RAG架构", "缓存策略", "向量检索优化"]
for q in queries:
    call_hybrid_search(q, limit=10)
```

#### 6.2 命中率采集
- 日志中打印 `cache_hit`, `cache_miss`, `cache_store` 事件，可用 `grep` 汇总：
```
grep -E "cache_(hit|miss|store)" app.log | wc -l
```
- 建议分层打点前缀：`embedding/retrieval/rerank/qa`，计算各层命中率。

### 7. 键设计与最佳实践
- 键包含关键影响因子（模型、文本、过滤条件、参数集合等），并做规范化（大小写、空白、标点处理）。
- 结构化对象使用 `json.dumps(..., sort_keys=True)`，再做 `sha256` 固化，避免顺序差异造成抖动。
- 对大上下文使用摘要/哈希替代原文入键，避免键过长。
- TTL 结合业务更新频率设定，并启用抖动避免雪崩；数据更新后需主动失效相关键。

### 8. 常见问题与排障
- 未启动 Redis：将 `cache_provider` 切为 `memory` 或启动 Redis。
- 命中率低：检查键规范化是否一致、参数是否固定、TTL 是否过短。
- 性能不升反降：小量/低频场景可适当降低 TTL 或关闭部分层缓存。
- 一致性问题：涉及文档更新后，请失效相关检索与 QA 键。

### 9. 变更参考
- 新增：`labs/full/lab03/src/utils/cache.py`（通用缓存模块）
- 配置：`labs/full/lab03/src/config/settings.py`（缓存开关、提供者、分层 TTL、抖动）
- 接入：`labs/full/lab03/src/services/embedding_service.py`（Embedding 层缓存）
- 待接入：Retrieval/Rerank/QA 层缓存、预热脚本、命中率采集汇总