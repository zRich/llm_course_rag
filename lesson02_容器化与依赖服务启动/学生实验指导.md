# Lesson 02 - 容器化与依赖服务启动

## 代码基础准备

在开始本节课的实验之前，我们需要切换到lesson02分支获取本课程的代码。

### 步骤1：进入项目目录

```bash
# 进入rag-system项目目录
cd rag-system
```

### 步骤2：切换到lesson02分支

```bash
# 切换到lesson02分支
git checkout lesson02

# 验证当前分支
git branch
# 应该显示 * lesson02
```

### 步骤3：验证代码状态

```bash
# 查看项目结构
ls -la
# 应该看到：src/ docker/ docker-compose.yml Dockerfile 等文件和目录

# 检查Docker配置文件
cat docker-compose.yml
# 应该看到完整的服务配置
```

**说明**：
- `lesson02`分支包含了lesson01的所有代码，并新增了Docker容器化配置
- 包含完整的`docker-compose.yml`文件，定义了RAG系统所需的所有服务
- 包含优化的`Dockerfile`和相关配置文件
- 这种方式确保了代码版本的一致性和完整性

---

## 实验目标

通过本次实验，你将：
- 掌握Docker容器化技术的基本使用
- 学会使用Docker Compose编排多服务应用
- 成功启动RAG系统所需的各种依赖服务
- 理解企业级应用的服务架构设计

## 环境准备

### 系统要求
- **操作系统**: Windows 10+, macOS 10.15+, 或 Linux
- **内存**: 至少 8GB RAM（推荐 16GB）
- **存储**: 至少 10GB 可用空间
- **网络**: 稳定的互联网连接

### 必需软件
1. **Docker Desktop**
   - Windows/macOS: 从 [docker.com](https://docker.com) 下载安装
   - Linux: 安装 Docker Engine 和 Docker Compose

2. **验证Docker安装**
   ```bash
   # 检查Docker版本
   docker --version
   docker-compose --version
   
   # 测试Docker运行
   docker run hello-world
   ```

## Exercise 1：为FastAPI应用创建Dockerfile

### 步骤1：创建Dockerfile

在项目根目录创建 `Dockerfile` 文件：

```dockerfile
# 使用官方Python基础镜像
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 设置环境变量
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY src/ ./src/
COPY scripts/ ./scripts/

# 创建非root用户
RUN useradd --create-home --shell /bin/bash app && \
    chown -R app:app /app
USER app

# 暴露端口
EXPOSE 8000

# 健康检查
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# 启动命令
CMD ["uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 步骤2：创建requirements.txt

创建 `requirements.txt` 文件：

```txt
# Web框架
fastapi==0.104.1
uvicorn[standard]==0.24.0

# 数据验证和配置
pydantic==2.5.0
pydantic-settings==2.1.0

# 数据库相关
sqlmodel==0.0.14
psycopg2-binary==2.9.9
redis==5.0.1

# 向量数据库
qdrant-client==1.7.0

# 对象存储
minio==7.2.0

# HTTP客户端
httpx==0.25.2
requests==2.31.0

# 工具库
python-multipart==0.0.6
python-dotenv==1.0.0
```

### 步骤3：创建.dockerignore

创建 `.dockerignore` 文件：

```dockerignore
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# 虚拟环境
.venv/
venv/
ENV/
env/

# 环境变量
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Git
.git/
.gitignore
README.md

# Docker
Dockerfile
docker-compose*.yml
.dockerignore

# 测试和文档
tests/
docs/
*.md

# 日志和临时文件
*.log
logs/
tmp/
temp/

# 数据库文件
*.db
*.sqlite3

# 操作系统
.DS_Store
Thumbs.db
```

### 步骤4：构建和测试镜像

```bash
# 构建Docker镜像
docker build -t rag-app:latest .

# 查看构建的镜像
docker images | grep rag-app

# 运行容器测试
docker run -d --name rag-test -p 8000:8000 rag-app:latest

# 测试应用
curl http://localhost:8000/health

# 查看容器日志
docker logs rag-test

# 停止并删除测试容器
docker stop rag-test
docker rm rag-test
```

## Exercise 2：使用Docker Compose编排服务

### 步骤1：创建基础docker-compose.yml

创建 `docker-compose.yml` 文件：

```yaml
version: '3.8'

services:
  # FastAPI应用
  app:
    build: .
    container_name: rag-app
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://rag:ragpass@postgres:5432/rag_db
      - REDIS_URL=redis://redis:6379/0
      - QDRANT_URL=http://qdrant:6333
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=minioadmin
      - MINIO_SECRET_KEY=minioadmin
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      qdrant:
        condition: service_started
      minio:
        condition: service_healthy
    networks:
      - rag-network
    restart: unless-stopped

  # PostgreSQL数据库
  postgres:
    image: postgres:15-alpine
    container_name: rag-postgres
    environment:
      POSTGRES_DB: rag_db
      POSTGRES_USER: rag
      POSTGRES_PASSWORD: ragpass
      POSTGRES_INITDB_ARGS: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    networks:
      - rag-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U rag -d rag_db"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: rag-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
      - ./config/redis.conf:/usr/local/etc/redis/redis.conf
    command: redis-server /usr/local/etc/redis/redis.conf
    networks:
      - rag-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Qdrant向量数据库
  qdrant:
    image: qdrant/qdrant:v1.7.0
    container_name: rag-qdrant
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - qdrant_data:/qdrant/storage
    networks:
      - rag-network
    restart: unless-stopped

  # MinIO对象存储
  minio:
    image: minio/minio:latest
    container_name: rag-minio
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    networks:
      - rag-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    restart: unless-stopped

# 数据卷
volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  qdrant_data:
    driver: local
  minio_data:
    driver: local

# 网络
networks:
  rag-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
```

### 步骤2：创建配置文件

#### 创建数据库初始化脚本

创建 `scripts/init-db.sql` 文件：

```sql
-- 创建扩展
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- 创建用户表
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT true,
    is_superuser BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建文档表
CREATE TABLE IF NOT EXISTS documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title VARCHAR(500) NOT NULL,
    content TEXT,
    file_path VARCHAR(1000),
    file_size INTEGER,
    mime_type VARCHAR(100),
    status VARCHAR(50) DEFAULT 'pending',
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建文档块表
CREATE TABLE IF NOT EXISTS document_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    chunk_index INTEGER NOT NULL,
    content TEXT NOT NULL,
    metadata JSONB,
    vector_id VARCHAR(100),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_documents_status ON documents(status);
CREATE INDEX IF NOT EXISTS idx_documents_created_by ON documents(created_by);
CREATE INDEX IF NOT EXISTS idx_document_chunks_document_id ON document_chunks(document_id);
CREATE INDEX IF NOT EXISTS idx_document_chunks_vector_id ON document_chunks(vector_id);

-- 创建全文搜索索引
CREATE INDEX IF NOT EXISTS idx_documents_content_gin ON documents USING gin(to_tsvector('english', content));
CREATE INDEX IF NOT EXISTS idx_document_chunks_content_gin ON document_chunks USING gin(to_tsvector('english', content));

-- 插入测试数据
INSERT INTO users (email, username, password_hash, is_superuser) 
VALUES ('admin@example.com', 'admin', '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj3QJK9N/B9u', true)
ON CONFLICT (email) DO NOTHING;

COMMIT;
```

#### 创建Redis配置文件

创建 `config/redis.conf` 文件：

```conf
# Redis配置文件

# 网络配置
bind 0.0.0.0
port 6379
protected-mode no

# 内存配置
maxmemory 512mb
maxmemory-policy allkeys-lru

# 持久化配置
save 900 1
save 300 10
save 60 10000

# 日志配置
loglevel notice
logfile ""

# 数据库配置
databases 16

# 安全配置
# requirepass yourpassword

# 性能配置
tcp-keepalive 300
timeout 0

# 其他配置
appendonly yes
appendfsync everysec
```

### 步骤3：更新应用配置

更新 `src/config.py` 文件：

```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    """应用配置"""
    
    # 应用基本信息
    app_name: str = "RAG System"
    app_version: str = "1.0.0"
    debug: bool = True
    
    # 服务器配置
    host: str = "0.0.0.0"
    port: int = 8000
    
    # 数据库配置
    database_url: str = "postgresql://rag:ragpass@localhost:5432/rag_db"
    redis_url: str = "redis://localhost:6379/0"
    
    # 向量数据库配置
    qdrant_url: str = "http://localhost:6333"
    
    # 对象存储配置
    minio_endpoint: str = "localhost:9000"
    minio_access_key: str = "minioadmin"
    minio_secret_key: str = "minioadmin"
    minio_secure: bool = False
    
    # LLM配置
    openai_api_key: Optional[str] = None
    openai_base_url: str = "https://api.openai.com/v1"
    
    # 日志配置
    log_level: str = "INFO"
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

# 创建全局配置实例
settings = Settings()
```

### 步骤4：启动服务栈

```bash
# 启动所有服务（后台运行）
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看服务日志
docker-compose logs -f

# 查看特定服务日志
docker-compose logs -f app
docker-compose logs -f postgres
```

## Exercise 3：服务验证和测试

### 步骤1：验证各服务状态

```bash
# 检查所有容器状态
docker-compose ps

# 检查网络
docker network ls
docker network inspect rag-course_rag-network

# 检查数据卷
docker volume ls
```

### 步骤2：测试服务连接

#### 测试FastAPI应用
```bash
# 健康检查
curl http://localhost:8000/health

# 系统信息
curl http://localhost:8000/system/info

# API文档
open http://localhost:8000/docs
```

#### 测试PostgreSQL
```bash
# 连接数据库
docker-compose exec postgres psql -U rag -d rag_db

# 在psql中执行
\dt  -- 查看表
SELECT * FROM users;  -- 查看用户数据
\q   -- 退出
```

#### 测试Redis
```bash
# 连接Redis
docker-compose exec redis redis-cli

# 在redis-cli中执行
ping
set test "hello"
get test
exit
```

#### 测试Qdrant
```bash
# 检查Qdrant状态
curl http://localhost:6333/

# 查看集合
curl http://localhost:6333/collections
```

#### 测试MinIO
```bash
# 检查MinIO状态
curl http://localhost:9000/minio/health/live

# 访问MinIO控制台
open http://localhost:9001
# 用户名: minioadmin
# 密码: minioadmin
```

### 步骤3：创建服务测试脚本

创建 `scripts/test_services.py` 文件：

```python
#!/usr/bin/env python3
"""
服务连接测试脚本
"""

import asyncio
import sys
import time
from typing import Dict, Any

import httpx
import psycopg2
import redis
from qdrant_client import QdrantClient
from minio import Minio

# 配置
CONFIG = {
    "app_url": "http://localhost:8000",
    "postgres": {
        "host": "localhost",
        "port": 5432,
        "database": "rag_db",
        "user": "rag",
        "password": "ragpass"
    },
    "redis": {
        "host": "localhost",
        "port": 6379,
        "db": 0
    },
    "qdrant": {
        "url": "http://localhost:6333"
    },
    "minio": {
        "endpoint": "localhost:9000",
        "access_key": "minioadmin",
        "secret_key": "minioadmin",
        "secure": False
    }
}

def test_fastapi():
    """测试FastAPI应用"""
    print("\n=== 测试FastAPI应用 ===")
    try:
        response = httpx.get(f"{CONFIG['app_url']}/health", timeout=10)
        if response.status_code == 200:
            print("✅ FastAPI应用运行正常")
            print(f"响应: {response.json()}")
            return True
        else:
            print(f"❌ FastAPI应用响应异常: {response.status_code}")
            return False
    except Exception as e:
        print(f"❌ FastAPI应用连接失败: {e}")
        return False

def test_postgres():
    """测试PostgreSQL连接"""
    print("\n=== 测试PostgreSQL ===")
    try:
        conn = psycopg2.connect(**CONFIG["postgres"])
        cursor = conn.cursor()
        cursor.execute("SELECT version();")
        version = cursor.fetchone()[0]
        print(f"✅ PostgreSQL连接成功")
        print(f"版本: {version}")
        
        # 测试表
        cursor.execute("SELECT COUNT(*) FROM users;")
        user_count = cursor.fetchone()[0]
        print(f"用户表记录数: {user_count}")
        
        cursor.close()
        conn.close()
        return True
    except Exception as e:
        print(f"❌ PostgreSQL连接失败: {e}")
        return False

def test_redis():
    """测试Redis连接"""
    print("\n=== 测试Redis ===")
    try:
        r = redis.Redis(**CONFIG["redis"])
        r.ping()
        print("✅ Redis连接成功")
        
        # 测试读写
        r.set("test_key", "test_value")
        value = r.get("test_key").decode()
        print(f"测试读写: {value}")
        r.delete("test_key")
        
        # 获取信息
        info = r.info()
        print(f"Redis版本: {info['redis_version']}")
        print(f"已用内存: {info['used_memory_human']}")
        return True
    except Exception as e:
        print(f"❌ Redis连接失败: {e}")
        return False

def test_qdrant():
    """测试Qdrant连接"""
    print("\n=== 测试Qdrant ===")
    try:
        client = QdrantClient(url=CONFIG["qdrant"]["url"])
        collections = client.get_collections()
        print("✅ Qdrant连接成功")
        print(f"集合数量: {len(collections.collections)}")
        
        # 获取集群信息
        cluster_info = client.get_cluster_info()
        print(f"节点状态: {cluster_info.status}")
        return True
    except Exception as e:
        print(f"❌ Qdrant连接失败: {e}")
        return False

def test_minio():
    """测试MinIO连接"""
    print("\n=== 测试MinIO ===")
    try:
        client = Minio(**CONFIG["minio"])
        
        # 检查服务
        buckets = client.list_buckets()
        print("✅ MinIO连接成功")
        print(f"存储桶数量: {len(buckets)}")
        
        # 创建测试桶
        bucket_name = "test-bucket"
        if not client.bucket_exists(bucket_name):
            client.make_bucket(bucket_name)
            print(f"创建测试桶: {bucket_name}")
        else:
            print(f"测试桶已存在: {bucket_name}")
        
        return True
    except Exception as e:
        print(f"❌ MinIO连接失败: {e}")
        return False

def main():
    """主测试函数"""
    print("开始服务连接测试...")
    print("="*50)
    
    tests = [
        ("FastAPI", test_fastapi),
        ("PostgreSQL", test_postgres),
        ("Redis", test_redis),
        ("Qdrant", test_qdrant),
        ("MinIO", test_minio)
    ]
    
    results = {}
    for name, test_func in tests:
        try:
            results[name] = test_func()
        except Exception as e:
            print(f"❌ {name}测试异常: {e}")
            results[name] = False
        time.sleep(1)  # 避免连接过快
    
    # 总结结果
    print("\n" + "="*50)
    print("📊 测试结果总结")
    print("="*50)
    
    passed = 0
    for name, success in results.items():
        status = "✅ 通过" if success else "❌ 失败"
        print(f"{name:12}: {status}")
        if success:
            passed += 1
    
    print(f"\n总计: {passed}/{len(results)} 项测试通过")
    
    if passed == len(results):
        print("🎉 所有服务连接测试通过！")
        sys.exit(0)
    else:
        print("⚠️ 部分服务连接失败，请检查配置")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

运行测试脚本：

```bash
# 安装测试依赖
uv add psycopg2-binary redis qdrant-client minio httpx

# 运行测试
python scripts/test_services.py
```

## Exercise 4：监控和日志管理

### 步骤1：添加监控服务

创建 `docker-compose.monitoring.yml` 文件：

```yaml
version: '3.8'

services:
  # Prometheus监控
  prometheus:
    image: prom/prometheus:latest
    container_name: rag-prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./config/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    networks:
      - rag-network
    restart: unless-stopped

  # Grafana可视化
  grafana:
    image: grafana/grafana:latest
    container_name: rag-grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
      - ./config/grafana/provisioning:/etc/grafana/provisioning
    networks:
      - rag-network
    restart: unless-stopped

volumes:
  prometheus_data:
  grafana_data:

networks:
  rag-network:
    external: true
```

### 步骤2：创建Prometheus配置

创建 `config/prometheus.yml` 文件：

```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'rag-app'
    static_configs:
      - targets: ['app:8000']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres:5432']
    scrape_interval: 30s

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:6379']
    scrape_interval: 30s
```

### 步骤3：启动监控服务

```bash
# 启动监控服务
docker-compose -f docker-compose.yml -f docker-compose.monitoring.yml up -d

# 访问Prometheus
open http://localhost:9090

# 访问Grafana
open http://localhost:3000
# 用户名: admin
# 密码: admin
```

## Exercise 5：服务管理和维护

### 步骤1：常用管理命令

```bash
# 查看服务状态
docker-compose ps

# 查看服务日志
docker-compose logs -f [service_name]

# 重启特定服务
docker-compose restart [service_name]

# 停止所有服务
docker-compose stop

# 停止并删除所有服务
docker-compose down

# 停止并删除所有服务和数据卷
docker-compose down -v

# 重新构建并启动
docker-compose up -d --build

# 扩展服务实例
docker-compose up -d --scale app=3
```

### 步骤2：数据备份脚本

创建 `scripts/backup.sh` 文件：

```bash
#!/bin/bash

# 数据备份脚本

set -e

BACKUP_DIR="./backups/$(date +%Y%m%d_%H%M%S)"
mkdir -p "$BACKUP_DIR"

echo "开始数据备份..."

# 备份PostgreSQL
echo "备份PostgreSQL数据库..."
docker-compose exec -T postgres pg_dump -U rag rag_db > "$BACKUP_DIR/postgres_backup.sql"

# 备份Redis
echo "备份Redis数据..."
docker-compose exec -T redis redis-cli BGSAVE
sleep 5
docker cp rag-redis:/data/dump.rdb "$BACKUP_DIR/redis_backup.rdb"

# 备份Qdrant
echo "备份Qdrant数据..."
docker cp rag-qdrant:/qdrant/storage "$BACKUP_DIR/qdrant_backup"

# 备份MinIO
echo "备份MinIO数据..."
docker cp rag-minio:/data "$BACKUP_DIR/minio_backup"

echo "备份完成: $BACKUP_DIR"
```

### 步骤3：健康检查脚本

创建 `scripts/health_check.sh` 文件：

```bash
#!/bin/bash

# 健康检查脚本

set -e

echo "开始健康检查..."

# 检查容器状态
echo "检查容器状态..."
docker-compose ps

# 检查应用健康
echo "检查应用健康..."
curl -f http://localhost:8000/health || exit 1

# 检查数据库连接
echo "检查数据库连接..."
docker-compose exec -T postgres pg_isready -U rag -d rag_db || exit 1

# 检查Redis连接
echo "检查Redis连接..."
docker-compose exec -T redis redis-cli ping || exit 1

# 检查Qdrant连接
echo "检查Qdrant连接..."
curl -f http://localhost:6333/ || exit 1

# 检查MinIO连接
echo "检查MinIO连接..."
curl -f http://localhost:9000/minio/health/live || exit 1

echo "所有服务健康检查通过！"
```

## 实验验证

### 检查清单

- [ ] Docker和Docker Compose已安装
- [ ] Dockerfile创建正确
- [ ] requirements.txt包含所需依赖
- [ ] docker-compose.yml配置完整
- [ ] 所有服务容器正常启动
- [ ] 服务间网络连通正常
- [ ] 数据持久化配置正确
- [ ] 健康检查正常工作
- [ ] 监控服务配置完成
- [ ] 备份脚本可以执行

### 功能测试

1. **容器构建测试**
   ```bash
   docker build -t rag-app:latest .
   # 应该成功构建镜像
   ```

2. **服务启动测试**
   ```bash
   docker-compose up -d
   docker-compose ps
   # 所有服务应该显示为Up状态
   ```

3. **连接测试**
   ```bash
   python scripts/test_services.py
   # 所有服务连接测试应该通过
   ```

4. **API测试**
   ```bash
   curl http://localhost:8000/health
   # 应该返回健康状态
   ```

## 思考题

1. **容器化优势**
   - 容器化相比传统部署方式有哪些优势？
   - 在什么场景下不适合使用容器化？

2. **服务架构设计**
   - 为什么要将数据库、缓存、应用分离到不同容器？
   - 如何设计服务间的依赖关系？

3. **数据持久化**
   - Docker卷和绑定挂载有什么区别？
   - 如何确保数据在容器重启后不丢失？

4. **网络配置**
   - Docker网络的作用是什么？
   - 如何实现服务间的安全通信？

5. **监控和维护**
   - 如何监控容器化应用的性能？
   - 容器化环境下如何进行故障排查？

## 常见问题解决

### Q1: Docker Desktop启动失败
**问题**: Docker Desktop无法启动
**解决方案**:
```bash
# 检查系统要求
# Windows: 启用Hyper-V和容器功能
# macOS: 检查内存分配

# 重置Docker Desktop
# Windows: 设置 -> Reset to factory defaults
# macOS: Troubleshoot -> Reset to factory defaults
```

### Q2: 容器启动失败
**问题**: 某个容器无法启动
**解决方案**:
```bash
# 查看容器日志
docker-compose logs [service_name]

# 检查端口占用
netstat -tulpn | grep [port]

# 检查磁盘空间
df -h

# 清理Docker资源
docker system prune -a
```

### Q3: 服务间连接失败
**问题**: 应用无法连接到数据库
**解决方案**:
```bash
# 检查网络配置
docker network ls
docker network inspect [network_name]

# 检查服务名解析
docker-compose exec app nslookup postgres

# 检查防火墙设置
sudo ufw status
```

### Q4: 数据丢失问题
**问题**: 容器重启后数据丢失
**解决方案**:
```bash
# 检查数据卷配置
docker volume ls
docker volume inspect [volume_name]

# 确保正确挂载
# 在docker-compose.yml中检查volumes配置
```

### Q5: 性能问题
**问题**: 容器运行缓慢
**解决方案**:
```bash
# 检查资源使用
docker stats

# 增加Docker内存限制
# Docker Desktop -> Settings -> Resources

# 优化镜像大小
# 使用多阶段构建
# 清理不必要的文件
```

## 参考资料

### 官方文档
- [Docker官方文档](https://docs.docker.com/)
- [Docker Compose文档](https://docs.docker.com/compose/)
- [PostgreSQL Docker镜像](https://hub.docker.com/_/postgres)
- [Redis Docker镜像](https://hub.docker.com/_/redis)
- [Qdrant文档](https://qdrant.tech/documentation/)
- [MinIO文档](https://docs.min.io/)

### 最佳实践
- [Dockerfile最佳实践](https://docs.docker.com/develop/dev-best-practices/)
- [Docker安全指南](https://docs.docker.com/engine/security/)
- [容器化应用的12要素](https://12factor.net/)

### 学习资源
- [Docker入门教程](https://docker-curriculum.com/)
- [Compose文件参考](https://docs.docker.com/compose/compose-file/)
- [容器编排最佳实践](https://kubernetes.io/docs/concepts/)

## 实验完成标志

当你完成以下所有项目时，说明实验成功：

✅ **容器化完成**
- Dockerfile创建正确
- 应用镜像构建成功
- 容器能够正常运行

✅ **服务编排完成**
- docker-compose.yml配置正确
- 所有依赖服务启动成功
- 服务间网络通信正常

✅ **数据持久化完成**
- 数据卷配置正确
- 数据在容器重启后保持
- 备份机制正常工作

✅ **监控配置完成**
- Prometheus收集指标正常
- Grafana可视化正常
- 健康检查机制工作

恭喜你完成了第二课的实验！你已经成功搭建了企业级RAG系统的容器化开发环境，并启动了所有必需的依赖服务。在下一课中，我们将学习如何设计和实现RAG系统的数据模型，以及如何进行数据库迁移。

## 实验完成后的Git操作

### 为什么要进行Git提交？

完成lesson02实验后，进行Git提交同样重要：

- **容器化配置保存**: 保存Docker和docker-compose配置文件
- **环境一致性**: 确保团队成员使用相同的容器化环境
- **版本追踪**: 记录容器化和服务配置的演进过程
- **回滚能力**: 当容器配置出现问题时，可以快速回退
- **部署记录**: 为生产环境部署提供参考配置

### Git提交操作步骤

完成本课实验后，请按照以下步骤提交你的代码：

#### 步骤1：检查当前状态

```bash
# 查看当前Git状态
git status

# 查看具体的文件变更
git diff
```

**预期看到的文件变更**:
- `Dockerfile` - 应用容器化配置
- `docker-compose.yml` - 服务编排配置
- `requirements.txt` - Python依赖列表
- `scripts/` - 各种脚本文件
- `.env.example` - 环境变量模板

#### 步骤2：添加文件到暂存区

```bash
# 添加所有更改的文件
git add .

# 或者选择性添加重要文件
git add Dockerfile
git add docker-compose.yml
git add requirements.txt
git add scripts/
git add .env.example

# 再次检查状态
git status
```

**注意**: 确保不要提交 `.env` 文件（包含敏感信息），只提交 `.env.example` 模板文件。

#### 步骤3：提交更改

```bash
# 提交更改并添加描述信息
git commit -m "完成lesson02实验：实现Docker容器化和服务编排"

# 或者使用更详细的提交信息
git commit -m "完成lesson02实验：Docker容器化和依赖服务启动

- 创建Dockerfile实现应用容器化
- 配置docker-compose.yml编排多个服务
- 集成PostgreSQL、Redis、Qdrant、MinIO服务
- 实现数据持久化和网络配置
- 添加健康检查和监控配置
- 创建服务管理和测试脚本
- 完成容器化环境的完整测试"
```

#### 步骤4：验证提交结果

```bash
# 查看提交历史
git log --oneline -5

# 查看最近一次提交的详细信息
git show HEAD

# 查看提交的文件列表
git show --name-only HEAD
```

### 容器化项目的特殊注意事项

#### 1. 环境变量管理
```bash
# 确保.env文件在.gitignore中
echo ".env" >> .gitignore

# 只提交.env.example模板
git add .env.example
```

#### 2. 数据卷和日志文件
```bash
# 确保数据目录不被提交
echo "data/" >> .gitignore
echo "logs/" >> .gitignore
echo "*.log" >> .gitignore
```

#### 3. Docker相关文件
```bash
# 可以选择忽略Docker构建缓存
echo ".dockerignore" >> .gitignore  # 如果不需要版本控制
```

### 验证容器化配置

提交前，建议进行最后一次完整验证：

```bash
# 停止所有服务
docker-compose down -v

# 清理镜像（可选）
docker system prune -f

# 重新构建和启动
docker-compose up --build -d

# 验证所有服务正常
docker-compose ps
python scripts/test_services.py

# 如果一切正常，再进行提交
git add .
git commit -m "验证通过：完成lesson02容器化配置"
```

### 可选：推送到远程仓库

```bash
# 推送到远程仓库
git push origin lesson02

# 如果是第一次推送该分支
git push -u origin lesson02
```

### 常见问题和解决方案

#### Q1: Docker相关文件过大
**问题**: 提交时发现文件过大
**解决方案**:
```bash
# 检查文件大小
du -sh *

# 添加到.gitignore
echo "*.tar" >> .gitignore
echo "*.gz" >> .gitignore
echo "data/" >> .gitignore
```

#### Q2: 敏感信息泄露
**问题**: 不小心提交了包含密码的.env文件
**解决方案**:
```bash
# 从Git历史中移除敏感文件
git rm --cached .env
echo ".env" >> .gitignore
git add .gitignore
git commit -m "移除敏感配置文件"
```

#### Q3: 容器状态不一致
**问题**: 提交后其他人无法正常启动容器
**解决方案**:
```bash
# 确保requirements.txt是最新的
pip freeze > requirements.txt
git add requirements.txt

# 确保docker-compose.yml版本兼容
# 使用稳定的镜像标签，避免使用latest
```

#### Q4: 网络端口冲突
**问题**: 端口配置在不同环境下冲突
**解决方案**:
```bash
# 在.env.example中提供端口配置说明
echo "# 端口配置 - 请根据本地环境调整" >> .env.example
echo "APP_PORT=8000" >> .env.example
echo "POSTGRES_PORT=5432" >> .env.example
```

### 容器化项目Git最佳实践

1. **分层提交**: 先提交基础配置，再提交服务配置
2. **标签管理**: 为稳定版本打标签
   ```bash
   git tag -a v0.2.0 -m "完成容器化配置"
   git push origin v0.2.0
   ```
3. **文档同步**: 确保README和docker-compose.yml保持同步
4. **测试验证**: 提交前在干净环境中测试容器启动
5. **安全检查**: 定期检查是否有敏感信息泄露

### 下一步

完成Git提交后，你的容器化配置已经安全保存。在lesson03中，我们将：
- 切换到 `lesson03` 分支
- 学习数据模型设计
- 实现数据库迁移功能
- 在容器化环境中进行数据库操作

容器化是现代应用开发的基础，良好的Git管理习惯将帮助你在团队协作中更加高效。记住，每次重要的配置变更都应该及时提交，这样可以确保环境的一致性和可追溯性。

---

## Lab 02：容器化RAG系统综合实验

### 实验目标
完成一个完整的容器化RAG系统部署，包括所有依赖服务的配置、数据持久化、监控和安全设置。

### 实验要求
1. **项目结构**: 创建名为 `lab02` 的项目目录
2. **完整配置**: 实现生产级的Docker配置
3. **服务编排**: 配置完整的服务栈
4. **数据持久化**: 实现数据卷管理
5. **监控日志**: 集成监控和日志系统
6. **安全配置**: 实现基本的安全措施
7. **文档完整**: 提供完整的部署和使用文档

### 提交要求
- 项目目录：`labs/lab02/`
- 必需文件：
  - `README.md` - 项目说明和使用指南
  - `Dockerfile` - 应用容器配置
  - `docker-compose.yml` - 服务编排配置
  - `requirements.txt` - Python依赖
  - `.env.example` - 环境变量模板
  - `docs/` - 详细文档目录
- 可选文件：
  - `nginx.conf` - 反向代理配置
  - `monitoring/` - 监控配置目录
  - `scripts/` - 部署脚本目录

### 评估标准
1. **功能完整性** (30%)：所有服务正常启动和运行
2. **配置质量** (25%)：Docker配置的专业性和最佳实践
3. **文档质量** (20%)：README和文档的完整性和清晰度
4. **安全性** (15%)：基本安全措施的实现
5. **创新性** (10%)：额外功能或优化的实现

### 提交方式
```bash
# 创建lab02目录
mkdir -p labs/lab02
cd labs/lab02

# 完成实验后提交
git add .
git commit -m "完成Lab 02：容器化RAG系统综合实验"
git push origin main
```