# 第17节课：结构化数据接入

## 课程信息
- **课程时长**：45分钟
- **课程目标**：实现结构化数据接入系统，支持API和数据库数据源与RAG系统集成
- **前置知识**：Python基础、HTTP协议、数据库基础、异步编程

## 1. 课程概述（5分钟）

### 1.1 为什么需要结构化数据接入？
- **数据源多样性**：企业数据分布在各种系统中（API、数据库、文件等）
- **实时性要求**：需要及时获取最新的业务数据
- **数据整合需求**：将分散的结构化数据统一接入RAG系统
- **业务价值**：让AI系统能够访问和理解企业的实时业务数据

### 1.2 结构化数据接入的核心概念
- **数据连接器**：统一的数据源接入接口
- **同步管理**：控制数据获取的时机和频率
- **数据转换**：将结构化数据转换为RAG系统可处理的格式
- **增量同步**：只获取变更的数据，提高效率

## 2. 技术原理讲解（15分钟）

### 2.1 数据连接器架构
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
import asyncio
import aiohttp
from datetime import datetime

class DataConnector(ABC):
    """数据连接器基类"""
    
    def __init__(self, connector_id: str, config: Dict[str, Any]):
        self.connector_id = connector_id
        self.config = config
        self.last_sync_time = None
        self.status = "initialized"
    
    @abstractmethod
    async def connect(self) -> bool:
        """建立连接"""
        pass
    
    @abstractmethod
    async def test_connection(self) -> Dict[str, Any]:
        """测试连接"""
        pass
    
    @abstractmethod
    async def fetch_data(self, endpoint: str, params: Dict = None) -> List[Dict]:
        """获取数据"""
        pass
    
    @abstractmethod
    async def get_schema(self) -> Dict[str, Any]:
        """获取数据结构"""
        pass
    
    async def disconnect(self):
        """断开连接"""
        self.status = "disconnected"

class APIConnector(DataConnector):
    """REST API连接器"""
    
    def __init__(self, connector_id: str, config: Dict[str, Any]):
        super().__init__(connector_id, config)
        self.base_url = config.get('base_url')
        self.headers = config.get('headers', {})
        self.timeout = config.get('timeout', 30)
        self.max_retries = config.get('max_retries', 3)
        self.session = None
    
    async def connect(self) -> bool:
        """建立HTTP连接"""
        try:
            connector = aiohttp.TCPConnector(limit=100)
            timeout = aiohttp.ClientTimeout(total=self.timeout)
            self.session = aiohttp.ClientSession(
                connector=connector,
                timeout=timeout,
                headers=self.headers
            )
            self.status = "connected"
            return True
        except Exception as e:
            self.status = f"connection_failed: {str(e)}"
            return False
    
    async def test_connection(self) -> Dict[str, Any]:
        """测试API连接"""
        if not self.session:
            await self.connect()
        
        try:
            async with self.session.get(f"{self.base_url}/") as response:
                return {
                    "status": "success",
                    "status_code": response.status,
                    "response_time": response.headers.get('X-Response-Time', 'N/A')
                }
        except Exception as e:
            return {
                "status": "failed",
                "error": str(e)
            }
    
    async def fetch_data(self, endpoint: str, params: Dict = None) -> List[Dict]:
        """从API获取数据"""
        if not self.session:
            await self.connect()
        
        url = f"{self.base_url}{endpoint}"
        retries = 0
        
        while retries < self.max_retries:
            try:
                async with self.session.get(url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data if isinstance(data, list) else [data]
                    else:
                        raise aiohttp.ClientResponseError(
                            request_info=response.request_info,
                            history=response.history,
                            status=response.status
                        )
            except Exception as e:
                retries += 1
                if retries >= self.max_retries:
                    raise e
                await asyncio.sleep(2 ** retries)  # 指数退避
        
        return []
```

### 2.2 数据库连接器实现
```python
import asyncpg
import aiomysql
from typing import Dict, List, Any

class DatabaseConnector(DataConnector):
    """数据库连接器"""
    
    def __init__(self, connector_id: str, config: Dict[str, Any]):
        super().__init__(connector_id, config)
        self.host = config.get('host')
        self.port = config.get('port')
        self.database = config.get('database')
        self.username = config.get('username')
        self.password = config.get('password')
        self.db_type = config.get('db_type', 'postgresql')
        self.connection_pool = None
    
    async def connect(self) -> bool:
        """建立数据库连接池"""
        try:
            if self.db_type == 'postgresql':
                self.connection_pool = await asyncpg.create_pool(
                    host=self.host,
                    port=self.port,
                    database=self.database,
                    user=self.username,
                    password=self.password,
                    min_size=1,
                    max_size=10
                )
            elif self.db_type == 'mysql':
                self.connection_pool = await aiomysql.create_pool(
                    host=self.host,
                    port=self.port,
                    db=self.database,
                    user=self.username,
                    password=self.password,
                    minsize=1,
                    maxsize=10
                )
            
            self.status = "connected"
            return True
        except Exception as e:
            self.status = f"connection_failed: {str(e)}"
            return False
    
    async def test_connection(self) -> Dict[str, Any]:
        """测试数据库连接"""
        if not self.connection_pool:
            await self.connect()
        
        try:
            async with self.connection_pool.acquire() as conn:
                if self.db_type == 'postgresql':
                    result = await conn.fetchval('SELECT version()')
                elif self.db_type == 'mysql':
                    async with conn.cursor() as cursor:
                        await cursor.execute('SELECT VERSION()')
                        result = await cursor.fetchone()
                
                return {
                    "status": "success",
                    "database_version": str(result)
                }
        except Exception as e:
            return {
                "status": "failed",
                "error": str(e)
            }
    
    async def fetch_data(self, query: str, params: Dict = None) -> List[Dict]:
        """执行SQL查询获取数据"""
        if not self.connection_pool:
            await self.connect()
        
        try:
            async with self.connection_pool.acquire() as conn:
                if self.db_type == 'postgresql':
                    rows = await conn.fetch(query, *(params.values() if params else []))
                    return [dict(row) for row in rows]
                elif self.db_type == 'mysql':
                    async with conn.cursor(aiomysql.DictCursor) as cursor:
                        await cursor.execute(query, params)
                        rows = await cursor.fetchall()
                        return rows
        except Exception as e:
            raise e
        
        return []
```

### 2.3 同步管理器
```python
import asyncio
from enum import Enum
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import json

class SyncType(Enum):
    FULL = "full"
    INCREMENTAL = "incremental"

class SyncStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

class SyncManager:
    """同步管理器"""
    
    def __init__(self):
        self.sync_jobs = {}
        self.connectors = {}
        self.sync_history = []
    
    def register_connector(self, connector: DataConnector):
        """注册数据连接器"""
        self.connectors[connector.connector_id] = connector
    
    async def start_sync(self, connector_id: str, sync_type: SyncType, 
                        config: Dict[str, Any]) -> str:
        """启动同步任务"""
        sync_id = f"{connector_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        sync_job = {
            'sync_id': sync_id,
            'connector_id': connector_id,
            'sync_type': sync_type,
            'status': SyncStatus.PENDING,
            'start_time': datetime.now(),
            'end_time': None,
            'config': config,
            'progress': 0,
            'total_records': 0,
            'processed_records': 0,
            'error_message': None
        }
        
        self.sync_jobs[sync_id] = sync_job
        
        # 异步执行同步任务
        asyncio.create_task(self._execute_sync(sync_id))
        
        return sync_id
    
    async def _execute_sync(self, sync_id: str):
        """执行同步任务"""
        sync_job = self.sync_jobs[sync_id]
        connector = self.connectors[sync_job['connector_id']]
        
        try:
            sync_job['status'] = SyncStatus.RUNNING
            
            # 获取数据
            endpoint = sync_job['config'].get('endpoint', '/')
            params = sync_job['config'].get('params', {})
            
            data = await connector.fetch_data(endpoint, params)
            sync_job['total_records'] = len(data)
            
            # 处理数据
            for i, record in enumerate(data):
                # 这里可以添加数据转换和存储逻辑
                await self._process_record(record, sync_job)
                sync_job['processed_records'] = i + 1
                sync_job['progress'] = int((i + 1) / len(data) * 100)
                
                # 模拟处理时间
                await asyncio.sleep(0.01)
            
            sync_job['status'] = SyncStatus.COMPLETED
            sync_job['end_time'] = datetime.now()
            
        except Exception as e:
            sync_job['status'] = SyncStatus.FAILED
            sync_job['error_message'] = str(e)
            sync_job['end_time'] = datetime.now()
        
        # 记录同步历史
        self.sync_history.append(sync_job.copy())
    
    async def _process_record(self, record: Dict, sync_job: Dict):
        """处理单条记录"""
        # 这里实现具体的数据处理逻辑
        # 例如：数据转换、验证、存储等
        pass
    
    def get_sync_status(self, sync_id: str) -> Optional[Dict]:
        """获取同步状态"""
        return self.sync_jobs.get(sync_id)
    
    def cancel_sync(self, sync_id: str) -> bool:
        """取消同步任务"""
        if sync_id in self.sync_jobs:
            sync_job = self.sync_jobs[sync_id]
            if sync_job['status'] in [SyncStatus.PENDING, SyncStatus.RUNNING]:
                sync_job['status'] = SyncStatus.CANCELLED
                sync_job['end_time'] = datetime.now()
                return True
        return False
```

## 3. 实践演示（15分钟）

### 3.1 创建API连接器演示
```python
# 演示创建和使用API连接器
async def demo_api_connector():
    # 配置API连接器
    config = {
        'base_url': 'https://jsonplaceholder.typicode.com',
        'headers': {'Content-Type': 'application/json'},
        'timeout': 30,
        'max_retries': 3
    }
    
    # 创建连接器
    api_connector = APIConnector('demo_api', config)
    
    # 建立连接
    connected = await api_connector.connect()
    print(f"连接状态: {connected}")
    
    # 测试连接
    test_result = await api_connector.test_connection()
    print(f"连接测试: {test_result}")
    
    # 获取数据
    posts = await api_connector.fetch_data('/posts', {'_limit': 5})
    print(f"获取到 {len(posts)} 条数据")