# Lesson 20: 故障注入与恢复演练 - 学生实验指导

## 实验概述

### 实验目标
- 掌握故障注入技术的基本原理和应用
- 学会实现和配置系统恢复机制
- 理解监控告警在系统可靠性中的作用
- 在RAG系统中应用容错设计模式

### 实验环境
- Python 3.8+
- 已完成的RAG系统项目
- 故障注入和恢复机制框架

### 预计时间
45分钟

## 实验准备

### 1. 环境检查
```bash
# 确认当前在lesson20分支
git branch

# 检查项目结构
ls -la src/fault_injection/
ls -la src/recovery/
ls -la src/monitoring/
```

### 2. 安装依赖
```bash
# 安装系统监控依赖
pip install psutil requests
```

### 3. 创建实验目录
```bash
# 在项目根目录创建实验文件夹
mkdir -p experiments/lesson20
cd experiments/lesson20
```

## 实验一：故障注入基础 (10分钟)

### 1.1 创建基础测试文件

创建文件 `fault_injection_demo.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
故障注入演示
"""

import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '../..'))

from src.fault_injection import FaultInjector, FaultType, fault_injection_decorator
import time
import random

def demo_basic_fault_injection():
    """演示基础故障注入"""
    print("=== 基础故障注入演示 ===")
    
    # 创建故障注入器
    injector = FaultInjector()
    
    # 配置网络超时故障
    injector.configure_fault(FaultType.NETWORK_TIMEOUT, probability=0.3)
    
    def simulate_api_call():
        """模拟API调用"""
        time.sleep(0.1)  # 正常响应时间
        return {"status": "success", "data": f"response_{random.randint(1, 100)}"}
    
    # 测试故障注入
    success_count = 0
    failure_count = 0
    
    for i in range(10):
        try:
            result = injector.inject_fault("api_call", simulate_api_call)
            print(f"✅ 调用 {i+1}: 成功 - {result}")
            success_count += 1
        except Exception as e:
            print(f"❌ 调用 {i+1}: 失败 - {str(e)}")
            failure_count += 1
    
    print(f"\n📊 统计结果: 成功 {success_count} 次, 失败 {failure_count} 次")
    print(f"📈 故障率: {failure_count/10*100:.1f}%")

def demo_decorator_fault_injection():
    """演示装饰器故障注入"""
    print("\n=== 装饰器故障注入演示 ===")
    
    @fault_injection_decorator(FaultType.SLOW_RESPONSE, probability=0.4)
    def process_request(data):
        """处理请求"""
        return f"处理完成: {data}"
    
    # 测试装饰器故障注入
    for i in range(5):
        start_time = time.time()
        try:
            result = process_request(f"request_{i}")
            duration = time.time() - start_time
            print(f"🔄 请求 {i+1}: {result}, 耗时: {duration:.2f}s")
        except Exception as e:
            duration = time.time() - start_time
            print(f"⏱️ 请求 {i+1}: 失败 - {str(e)}, 耗时: {duration:.2f}s")

def demo_multiple_fault_types():
    """演示多种故障类型"""
    print("\n=== 多种故障类型演示 ===")
    
    injector = FaultInjector()
    
    # 配置多种故障
    injector.configure_fault(FaultType.SERVICE_UNAVAILABLE, probability=0.2)
    injector.configure_fault(FaultType.DATA_CORRUPTION, probability=0.1)
    injector.configure_fault(FaultType.MEMORY_ERROR, probability=0.1)
    
    def database_operation(operation_type):
        """模拟数据库操作"""
        operations = {
            "read": lambda: {"data": ["item1", "item2", "item3"]},
            "write": lambda: {"status": "written", "id": random.randint(1, 1000)},
            "delete": lambda: {"status": "deleted", "count": 1}
        }
        return operations[operation_type]()
    
    operations = ["read", "write", "delete"] * 3
    
    for i, op in enumerate(operations):
        try:
            result = injector.inject_fault(f"db_{op}", lambda: database_operation(op))
            print(f"💾 操作 {i+1} ({op}): 成功 - {result}")
        except Exception as e:
            print(f"💥 操作 {i+1} ({op}): 失败 - {str(e)}")

if __name__ == "__main__":
    demo_basic_fault_injection()
    demo_decorator_fault_injection()
    demo_multiple_fault_types()
    
    print("\n🎯 实验一完成！请观察不同故障类型的表现。")
```

### 1.2 运行实验一
```bash
python fault_injection_demo.py
```

### 1.3 观察和记录
- 记录不同故障类型的表现
- 观察故障概率的实际效果
- 思考：哪些故障类型对系统影响最大？

## 实验二：恢复机制实践 (15分钟)

### 2.1 创建恢复机制测试文件

创建文件 `recovery_demo.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
恢复机制演示
"""

import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '../..'))

from src.recovery import (
    retry_with_backoff, RetryStrategy, 
    CircuitBreaker, CircuitBreakerState,
    FallbackService, FallbackStrategy
)
import time
import random

def demo_retry_mechanism():
    """演示重试机制"""
    print("=== 重试机制演示 ===")
    
    # 模拟不稳定的服务
    call_count = 0
    
    @retry_with_backoff(
        max_attempts=3,
        strategy=RetryStrategy.EXPONENTIAL_BACKOFF,
        base_delay=0.5
    )
    def unreliable_service(service_name):
        nonlocal call_count
        call_count += 1
        
        print(f"  🔄 尝试调用 {service_name} (第 {call_count} 次)")
        
        # 70%的失败率
        if random.random() < 0.7:
            raise Exception(f"{service_name} 服务临时不可用")
        
        return f"{service_name} 调用成功"
    
    # 测试重试机制
    services = ["用户服务", "订单服务", "支付服务"]
    
    for service in services:
        call_count = 0
        try:
            start_time = time.time()
            result = unreliable_service(service)
            duration = time.time() - start_time
            print(f"✅ {service}: {result} (耗时: {duration:.2f}s, 尝试次数: {call_count})")
        except Exception as e:
            duration = time.time() - start_time
            print(f"❌ {service}: 最终失败 - {str(e)} (耗时: {duration:.2f}s, 尝试次数: {call_count})")
        print()

def demo_circuit_breaker():
    """演示熔断器模式"""
    print("\n=== 熔断器模式演示 ===")
    
    # 创建熔断器
    breaker = CircuitBreaker(
        failure_threshold=3,
        timeout_seconds=5,
        half_open_max_calls=2
    )
    
    def failing_service(request_id):
        """经常失败的服务"""
        # 80%的失败率
        if random.random() < 0.8:
            raise Exception(f"服务错误 (请求 {request_id})")
        return f"请求 {request_id} 处理成功"
    
    print("开始测试熔断器...")
    
    # 测试熔断器
    for i in range(15):
        try:
            result = breaker.call(lambda: failing_service(i+1))
            print(f"✅ 调用 {i+1}: {result} (状态: {breaker.state.value})")
        except Exception as e:
            print(f"❌ 调用 {i+1}: {str(e)} (状态: {breaker.state.value})")
        
        # 显示熔断器统计
        stats = breaker.get_statistics()
        print(f"   📊 成功率: {stats['success_rate']:.1f}%, 失败率: {stats['failure_rate']:.1f}%")
        
        time.sleep(0.5)
        
        # 在熔断器打开时，等待一段时间让它进入半开状态
        if breaker.state == CircuitBreakerState.OPEN and i == 8:
            print("\n⏳ 等待熔断器超时，进入半开状态...")
            time.sleep(6)

def demo_fallback_service():
    """演示降级服务"""
    print("\n=== 降级服务演示 ===")
    
    # 创建降级服务
    fallback = FallbackService()
    fallback.configure(FallbackStrategy.CACHE, cache_ttl=10)
    
    def get_user_profile(user_id):
        """获取用户资料"""
        # 50%的失败率
        if random.random() < 0.5:
            raise Exception(f"用户服务不可用 (用户 {user_id})")
        
        return {
            "id": user_id,
            "name": f"User{user_id}",
            "email": f"user{user_id}@example.com",
            "created_at": time.time()
        }
    
    # 测试降级服务
    user_ids = [1, 2, 1, 3, 2, 4, 1]  # 重复访问用户1和2测试缓存
    
    for user_id in user_ids:
        try:
            result = fallback.execute_with_fallback(
                f"user_profile_{user_id}",
                lambda: get_user_profile(user_id),
                default_value={
                    "id": user_id,
                    "name": f"默认用户{user_id}",
                    "email": "default@example.com",
                    "created_at": time.time()
                }
            )
            
            # 检查是否来自缓存
            cache_hit = "created_at" in result and time.time() - result["created_at"] > 1
            cache_status = "(缓存命中)" if cache_hit else "(实时数据)"
            
            print(f"👤 用户 {user_id}: {result['name']} {cache_status}")
            
        except Exception as e:
            print(f"❌ 用户 {user_id}: 获取失败 - {str(e)}")
        
        time.sleep(0.5)
    
    # 显示降级服务统计
    stats = fallback.get_statistics()
    print(f"\n📊 降级服务统计:")
    print(f"   总调用: {stats['total_calls']}")
    print(f"   成功: {stats['successful_calls']}")
    print(f"   降级: {stats['fallback_calls']}")
    print(f"   缓存命中: {stats['cache_hits']}")

if __name__ == "__main__":
    demo_retry_mechanism()
    demo_circuit_breaker()
    demo_fallback_service()
    
    print("\n🎯 实验二完成！请观察不同恢复机制的效果。")
```

### 2.2 运行实验二
```bash
python recovery_demo.py
```

### 2.3 观察和分析
- 观察重试机制的延迟策略
- 记录熔断器状态转换过程
- 分析降级服务的缓存效果

## 实验三：监控告警系统 (10分钟)

### 3.1 创建监控演示文件

创建文件 `monitoring_demo.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
监控告警演示
"""

import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '../..'))

from src.monitoring import (
    global_system_monitor, global_alert_manager, global_metrics_collector,
    create_error_rate_rule, create_response_time_rule,
    AlertLevel, AlertCondition, AlertRule
)
import time
import random

def demo_metrics_collection():
    """演示指标收集"""
    print("=== 指标收集演示 ===")
    
    collector = global_metrics_collector
    
    # 模拟业务指标
    print("📊 开始收集指标...")
    
    for i in range(10):
        # 模拟请求处理
        response_time = random.uniform(0.1, 2.0)
        success = random.random() > 0.1  # 90%成功率
        
        # 记录指标
        collector.record_counter("requests_total", 1, {"status": "success" if success else "error"})
        collector.record_timer("response_time", response_time, {"endpoint": "/api/search"})
        collector.record_gauge("active_connections", random.randint(10, 50))
        
        if success:
            print(f"✅ 请求 {i+1}: 成功, 响应时间: {response_time:.2f}s")
        else:
            print(f"❌ 请求 {i+1}: 失败, 响应时间: {response_time:.2f}s")
        
        time.sleep(0.2)
    
    # 显示指标摘要
    print("\n📈 指标摘要:")
    metrics = collector.get_metrics_summary()
    for name, data in metrics.items():
        if 'count' in data:
            print(f"   {name}: {data['count']} 次")
        elif 'value' in data:
            print(f"   {name}: {data['value']:.2f}")

def demo_alert_system():
    """演示告警系统"""
    print("\n=== 告警系统演示 ===")
    
    alert_manager = global_alert_manager
    
    # 添加告警规则
    error_rule = create_error_rate_rule(
        "high_error_rate",
        threshold=0.15,  # 15%错误率
        level=AlertLevel.WARNING
    )
    
    response_rule = create_response_time_rule(
        "slow_response",
        threshold=1.5,  # 1.5秒响应时间
        level=AlertLevel.ERROR
    )
    
    # 自定义规则：活跃连接数过高
    connection_rule = AlertRule(
        name="high_connections",
        metric_name="active_connections",
        condition=AlertCondition.GREATER_THAN,
        threshold=40,
        level=AlertLevel.WARNING,
        description="活跃连接数过高"
    )
    
    alert_manager.add_rule(error_rule)
    alert_manager.add_rule(response_rule)
    alert_manager.add_rule(connection_rule)
    
    print("🚨 开始监控告警...")
    
    # 模拟指标变化触发告警
    for i in range(15):
        # 逐渐增加错误率
        error_rate = 0.05 + (i * 0.02)
        
        # 随机响应时间，偶尔很慢
        response_time = random.uniform(0.5, 3.0) if random.random() > 0.7 else random.uniform(0.1, 1.0)
        
        # 活跃连接数
        connections = random.randint(20, 60)
        
        # 评估指标
        alert_manager.evaluate_metric("error_rate", error_rate)
        alert_manager.evaluate_metric("response_time", response_time)
        alert_manager.evaluate_metric("active_connections", connections)
        
        print(f"📊 周期 {i+1}: 错误率={error_rate:.2f}, 响应时间={response_time:.2f}s, 连接数={connections}")
        
        # 显示活跃告警
        active_alerts = alert_manager.get_active_alerts()
        if active_alerts:
            for alert in active_alerts:
                print(f"   🚨 告警: {alert.rule_name} - {alert.message}")
        
        time.sleep(0.5)
    
    # 显示告警统计
    print("\n📊 告警统计:")
    stats = alert_manager.get_statistics()
    print(f"   总告警数: {stats['total_alerts']}")
    print(f"   活跃告警: {stats['active_alerts']}")
    print(f"   已解决: {stats['resolved_alerts']}")

def demo_system_health():
    """演示系统健康检查"""
    print("\n=== 系统健康检查演示 ===")
    
    monitor = global_system_monitor
    
    # 运行健康检查
    print("🏥 执行健康检查...")
    results = monitor.run_all_health_checks()
    
    for result in results:
        status_icon = "✅" if result.status.value == "healthy" else "❌"
        print(f"{status_icon} {result.name}: {result.message} ({result.duration_ms:.1f}ms)")
    
    # 获取系统指标
    print("\n💻 系统指标:")
    try:
        metrics = monitor.get_system_metrics()
        print(f"   CPU使用率: {metrics.cpu_percent:.1f}%")
        print(f"   内存使用率: {metrics.memory_percent:.1f}%")
        print(f"   可用内存: {metrics.memory_available_mb:.0f}MB")
        print(f"   磁盘使用率: {metrics.disk_usage_percent:.1f}%")
        print(f"   进程数: {metrics.process_count}")
        if metrics.load_average:
            print(f"   负载平均值: {metrics.load_average}")
    except Exception as e:
        print(f"   ❌ 获取系统指标失败: {str(e)}")
    
    # 获取整体健康状态
    overall_health = monitor.get_overall_health()
    health_icon = {
        "healthy": "💚",
        "warning": "💛", 
        "unhealthy": "❤️",
        "unknown": "🤍"
    }.get(overall_health.value, "🤍")
    
    print(f"\n{health_icon} 系统整体健康状态: {overall_health.value.upper()}")

if __name__ == "__main__":
    demo_metrics_collection()
    demo_alert_system()
    demo_system_health()
    
    print("\n🎯 实验三完成！请观察监控告警系统的运行情况。")
```

### 3.2 运行实验三
```bash
python monitoring_demo.py
```

## 实验四：RAG系统集成 (10分钟)

### 4.1 创建RAG集成示例

创建文件 `rag_integration_demo.py`：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RAG系统容错集成演示
"""

import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '../..'))

from src.fault_injection import fault_injection_decorator, FaultType
from src.recovery import (
    retry_with_backoff, RetryStrategy,
    CircuitBreaker, FallbackService, FallbackStrategy
)
from src.monitoring import global_metrics_collector, global_alert_manager
import time
import random

class RobustRAGService:
    """容错的RAG服务"""
    
    def __init__(self):
        self.vector_circuit_breaker = CircuitBreaker(failure_threshold=3)
        self.llm_circuit_breaker = CircuitBreaker(failure_threshold=2)
        self.fallback_service = FallbackService()
        self.fallback_service.configure(FallbackStrategy.CACHE, cache_ttl=300)
        
        # 初始化指标收集
        self.metrics = global_metrics_collector
        
        print("🤖 RobustRAGService 初始化完成")
    
    @fault_injection_decorator(FaultType.NETWORK_TIMEOUT, probability=0.1)
    @retry_with_backoff(max_attempts=3, strategy=RetryStrategy.EXPONENTIAL_BACKOFF)
    def query_vector_store(self, query):
        """查询向量存储"""
        start_time = time.time()
        
        try:
            # 模拟向量查询
            if random.random() < 0.2:  # 20%失败率
                raise Exception("向量存储查询失败")
            
            # 模拟查询延迟
            time.sleep(random.uniform(0.1, 0.5))
            
            docs = [
                f"文档1: 关于{query}的相关内容...",
                f"文档2: {query}的详细说明...",
                f"文档3: {query}的应用案例..."
            ]
            
            # 记录成功指标
            duration = time.time() - start_time
            self.metrics.record_timer("vector_query_duration", duration)
            self.metrics.record_counter("vector_queries_total", 1, {"status": "success"})
            
            return docs
            
        except Exception as e:
            # 记录失败指标
            duration = time.time() - start_time
            self.metrics.record_timer("vector_query_duration", duration)
            self.metrics.record_counter("vector_queries_total", 1, {"status": "error"})
            raise e
    
    @fault_injection_decorator(FaultType.SLOW_RESPONSE, probability=0.15)
    def generate_response(self, context, query):
        """生成回答"""
        start_time = time.time()
        
        try:
            # 使用熔断器保护LLM调用
            def llm_call():
                if random.random() < 0.25:  # 25%失败率
                    raise Exception("LLM服务不可用")
                
                # 模拟LLM处理时间
                time.sleep(random.uniform(0.2, 1.0))
                
                return f"基于提供的上下文，关于'{query}'的回答是：这是一个详细的解答，结合了相关文档的信息。"
            
            response = self.llm_circuit_breaker.call(llm_call)
            
            # 记录成功指标
            duration = time.time() - start_time
            self.metrics.record_timer("llm_response_duration", duration)
            self.metrics.record_counter("llm_calls_total", 1, {"status": "success"})
            
            return response
            
        except Exception as e:
            # 记录失败指标
            duration = time.time() - start_time
            self.metrics.record_timer("llm_response_duration", duration)
            self.metrics.record_counter("llm_calls_total", 1, {"status": "error"})
            raise e
    
    def search_with_fallback(self, query):
        """带降级的搜索"""
        def primary_search():
            # 查询向量存储
            docs = self.query_vector_store(query)
            
            # 生成回答
            response = self.generate_response(docs, query)
            
            return {
                "success": True,
                "response": response,
                "source": "primary",
                "documents": len(docs)
            }
        
        # 使用降级服务
        try:
            result = self.fallback_service.execute_with_fallback(
                f"search_{hash(query) % 1000}",  # 简单的缓存键
                primary_search,
                default_value={
                    "success": True,
                    "response": f"抱歉，由于系统繁忙，无法提供关于'{query}'的详细回答。请稍后重试。",
                    "source": "fallback",
                    "documents": 0
                }
            )
            
            # 记录搜索指标
            self.metrics.record_counter("searches_total", 1, {"source": result["source"]})
            
            return result
            
        except Exception as e:
            # 最终降级
            self.metrics.record_counter("searches_total", 1, {"source": "error"})
            return {
                "success": False,
                "error": str(e),
                "response": "系统暂时不可用，请稍后重试。",
                "source": "error"
            }

def demo_rag_integration():
    """演示RAG系统集成"""
    print("=== RAG系统容错集成演示 ===")
    
    # 创建容错RAG服务
    rag_service = RobustRAGService()
    
    # 测试查询
    queries = [
        "什么是机器学习？",
        "深度学习的应用场景",
        "自然语言处理技术",
        "推荐系统算法",
        "计算机视觉发展",
        "什么是机器学习？",  # 重复查询测试缓存
        "人工智能伦理",
        "大数据分析方法"
    ]
    
    print(f"🔍 开始执行 {len(queries)} 个查询...\n")
    
    for i, query in enumerate(queries):
        print(f"📝 查询 {i+1}: {query}")
        
        start_time = time.time()
        result = rag_service.search_with_fallback(query)
        duration = time.time() - start_time
        
        if result["success"]:
            source_icon = {
                "primary": "🎯",
                "fallback": "🔄",
                "cache": "💾"
            }.get(result["source"], "❓")
            
            print(f"   {source_icon} 成功 ({result['source']}) - 耗时: {duration:.2f}s")
            print(f"   📄 文档数: {result.get('documents', 0)}")
            print(f"   💬 回答: {result['response'][:100]}...")
        else:
            print(f"   ❌ 失败 - {result['error']} (耗时: {duration:.2f}s)")
            print(f"   💬 降级回答: {result['response']}")
        
        print()
        time.sleep(0.5)
    
    # 显示服务统计
    print("📊 服务统计:")
    
    # 熔断器状态
    print(f"   🔌 向量存储熔断器: {rag_service.vector_circuit_breaker.state.value}")
    print(f"   🤖 LLM熔断器: {rag_service.llm_circuit_breaker.state.value}")
    
    # 降级服务统计
    fallback_stats = rag_service.fallback_service.get_statistics()
    print(f"   🔄 降级服务调用: {fallback_stats['total_calls']}")
    print(f"   💾 缓存命中: {fallback_stats['cache_hits']}")
    
    # 指标统计
    metrics = rag_service.metrics.get_metrics_summary()
    print(f"\n📈 性能指标:")
    for name, data in metrics.items():
        if 'count' in data:
            print(f"   {name}: {data['count']} 次")
        elif 'avg' in data:
            print(f"   {name}: 平均 {data['avg']:.2f}s")

if __name__ == "__main__":
    demo_rag_integration()
    
    print("\n🎯 实验四完成！RAG系统容错机制集成演示结束。")
```

### 4.2 运行实验四
```bash
python rag_integration_demo.py
```

## 实验总结

### 完成实验后，请回答以下问题：

1. **故障注入的价值**：
   - 故障注入帮助发现了哪些潜在问题？
   - 不同故障类型对系统的影响有何不同？

2. **恢复机制效果**：
   - 重试机制在什么情况下最有效？
   - 熔断器如何保护系统免受级联故障？
   - 降级服务如何提升用户体验？

3. **监控告警作用**：
   - 监控指标如何帮助及时发现问题？
   - 告警规则应该如何设置才合理？

4. **集成应用思考**：
   - 在RAG系统中，哪些组件最需要容错保护？
   - 如何平衡系统性能和可靠性？

### 扩展练习

1. **自定义故障类型**：
   - 为RAG系统设计特定的故障场景
   - 实现自定义的故障注入逻辑

2. **优化恢复策略**：
   - 调整重试参数，观察效果变化
   - 设计更智能的降级策略

3. **完善监控体系**：
   - 添加业务相关的监控指标
   - 设计更精确的告警规则

### 注意事项

⚠️ **重要提醒**：
- 故障注入仅在测试环境使用
- 生产环境部署前需充分测试
- 监控告警要避免过于敏感
- 恢复机制参数需根据实际业务调整

---

**实验完成标志**：
- ✅ 成功运行所有四个实验
- ✅ 观察到故障注入和恢复机制的效果
- ✅ 理解监控告警的作用
- ✅ 掌握在RAG系统中的集成方法

**下一步学习**：
- 深入学习Chaos Engineering
- 研究微服务容错模式
- 探索更高级的监控技术