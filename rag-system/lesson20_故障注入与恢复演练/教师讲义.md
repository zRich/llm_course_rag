# Lesson 20: 故障注入与恢复演练 - 教师讲义

## 课程信息
- **课程时长**: 45分钟
- **课程类型**: 实践演练课
- **前置知识**: RAG系统架构、Python编程基础
- **学习目标**: 掌握故障注入技术和系统恢复机制

## 教学大纲

### 第一部分：理论基础 (10分钟)

#### 1.1 故障注入概念 (3分钟)
- **定义**: 故障注入是一种测试技术，通过人为引入故障来验证系统的容错能力
- **目的**: 
  - 验证系统在异常情况下的行为
  - 测试恢复机制的有效性
  - 提高系统的可靠性和稳定性
- **应用场景**: 分布式系统、微服务架构、关键业务系统

#### 1.2 故障类型分析 (4分钟)
- **网络故障**: 超时、连接中断、丢包
- **服务故障**: 服务不可用、响应慢、内存不足
- **数据故障**: 数据损坏、读写错误、存储满
- **系统故障**: CPU过载、内存泄漏、磁盘故障

#### 1.3 恢复机制策略 (3分钟)
- **重试机制**: 指数退避、固定间隔、随机抖动
- **熔断器模式**: 快速失败、半开状态、自动恢复
- **降级服务**: 缓存策略、默认值、备用服务
- **监控告警**: 实时监控、阈值告警、自动通知

### 第二部分：框架介绍 (8分钟)

#### 2.1 故障注入框架 (4分钟)
```python
# 展示核心组件
from src.fault_injection import FaultInjector, FaultType

# 创建故障注入器
injector = FaultInjector()

# 配置故障类型
injector.configure_fault(FaultType.NETWORK_TIMEOUT, probability=0.1)
```

**关键特性**:
- 支持6种故障类型
- 可配置故障概率
- 统计和监控功能
- 装饰器模式集成

#### 2.2 恢复机制框架 (4分钟)
```python
# 重试机制示例
from src.recovery import retry_with_backoff, CircuitBreaker

@retry_with_backoff(max_attempts=3)
def unreliable_operation():
    # 可能失败的操作
    pass

# 熔断器示例
breaker = CircuitBreaker(failure_threshold=5)
result = breaker.call(risky_function)
```

**核心组件**:
- 重试策略配置
- 熔断器状态管理
- 降级服务实现
- 监控指标收集

### 第三部分：实践演练 (22分钟)

#### 3.1 环境准备 (3分钟)
1. **检查项目结构**
   ```bash
   # 查看故障注入模块
   ls -la src/fault_injection/
   ls -la src/recovery/
   ls -la src/monitoring/
   ```

2. **安装依赖**
   ```bash
   pip install psutil requests
   ```

#### 3.2 故障注入演练 (8分钟)

**演练1: 网络超时故障** (3分钟)
```python
# 创建测试脚本
from src.fault_injection import FaultInjector, FaultType
import time

def simulate_api_call():
    """模拟API调用"""
    time.sleep(0.1)  # 正常响应时间
    return {"status": "success", "data": "response"}

# 注入网络超时故障
injector = FaultInjector()
injector.configure_fault(FaultType.NETWORK_TIMEOUT, probability=0.3)

# 测试故障注入
for i in range(10):
    try:
        result = injector.inject_fault("api_call", simulate_api_call)
        print(f"调用 {i+1}: 成功 - {result}")
    except Exception as e:
        print(f"调用 {i+1}: 失败 - {str(e)}")
```

**演练2: 服务不可用故障** (3分钟)
```python
# 服务不可用测试
injector.configure_fault(FaultType.SERVICE_UNAVAILABLE, probability=0.2)

def database_query():
    return {"users": ["user1", "user2"]}

# 测试数据库查询故障
for i in range(5):
    try:
        result = injector.inject_fault("db_query", database_query)
        print(f"查询 {i+1}: {result}")
    except Exception as e:
        print(f"查询 {i+1}: 数据库不可用 - {str(e)}")
```

**演练3: 装饰器模式** (2分钟)
```python
from src.fault_injection import fault_injection_decorator

@fault_injection_decorator(FaultType.SLOW_RESPONSE, probability=0.2)
def process_request(data):
    return f"处理完成: {data}"

# 测试装饰器故障注入
for i in range(5):
    start_time = time.time()
    result = process_request(f"request_{i}")
    duration = time.time() - start_time
    print(f"请求 {i+1}: {result}, 耗时: {duration:.2f}s")
```

#### 3.3 恢复机制演练 (8分钟)

**演练4: 重试机制** (3分钟)
```python
from src.recovery import retry_with_backoff, RetryStrategy
import random

@retry_with_backoff(
    max_attempts=3,
    strategy=RetryStrategy.EXPONENTIAL_BACKOFF,
    base_delay=1.0
)
def unreliable_service():
    """不稳定的服务"""
    if random.random() < 0.7:  # 70%失败率
        raise Exception("服务临时不可用")
    return "服务调用成功"

# 测试重试机制
for i in range(3):
    try:
        result = unreliable_service()
        print(f"尝试 {i+1}: {result}")
    except Exception as e:
        print(f"尝试 {i+1}: 最终失败 - {str(e)}")
```

**演练5: 熔断器模式** (3分钟)
```python
from src.recovery import CircuitBreaker

# 创建熔断器
breaker = CircuitBreaker(
    failure_threshold=3,
    timeout_seconds=10,
    half_open_max_calls=2
)

def failing_service():
    """经常失败的服务"""
    if random.random() < 0.8:  # 80%失败率
        raise Exception("服务错误")
    return "服务正常"

# 测试熔断器
for i in range(10):
    try:
        result = breaker.call(failing_service)
        print(f"调用 {i+1}: {result}")
    except Exception as e:
        print(f"调用 {i+1}: {str(e)} (状态: {breaker.state.value})")
    time.sleep(1)
```

**演练6: 降级服务** (2分钟)
```python
from src.recovery import FallbackService, FallbackStrategy

# 创建降级服务
fallback = FallbackService()
fallback.configure(FallbackStrategy.CACHE, cache_ttl=60)

def get_user_info(user_id):
    """获取用户信息"""
    if random.random() < 0.5:
        raise Exception("用户服务不可用")
    return {"id": user_id, "name": f"User{user_id}"}

# 测试降级服务
for user_id in [1, 2, 1, 3]:
    try:
        result = fallback.execute_with_fallback(
            f"user_{user_id}",
            lambda: get_user_info(user_id),
            default_value={"id": user_id, "name": "默认用户"}
        )
        print(f"用户 {user_id}: {result}")
    except Exception as e:
        print(f"用户 {user_id}: 获取失败 - {str(e)}")
```

#### 3.4 监控告警演练 (3分钟)

**演练7: 系统监控** (3分钟)
```python
from src.monitoring import global_system_monitor, global_alert_manager
from src.monitoring import create_error_rate_rule, AlertLevel

# 启动系统监控
monitor = global_system_monitor
monitor.start_monitoring()

# 配置告警规则
alert_manager = global_alert_manager
error_rule = create_error_rate_rule(
    "high_error_rate",
    threshold=0.1,  # 10%错误率
    level=AlertLevel.WARNING
)
alert_manager.add_rule(error_rule)

# 模拟错误率上升
for i in range(20):
    error_rate = 0.05 + (i * 0.01)  # 逐渐增加错误率
    alert_manager.evaluate_metric("error_rate", error_rate)
    time.sleep(0.5)

# 查看告警状态
active_alerts = alert_manager.get_active_alerts()
print(f"活跃告警数量: {len(active_alerts)}")

# 获取系统指标
metrics = monitor.get_system_metrics()
print(f"CPU使用率: {metrics.cpu_percent}%")
print(f"内存使用率: {metrics.memory_percent}%")

# 停止监控
monitor.stop_monitoring()
```

### 第四部分：综合应用 (5分钟)

#### 4.1 RAG系统集成示例 (3分钟)
```python
# 在RAG服务中集成故障注入和恢复机制
from src.fault_injection import fault_injection_decorator, FaultType
from src.recovery import retry_with_backoff, circuit_breaker_decorator

class RobustRAGService:
    def __init__(self):
        self.circuit_breaker = CircuitBreaker(failure_threshold=5)
    
    @fault_injection_decorator(FaultType.NETWORK_TIMEOUT, probability=0.05)
    @retry_with_backoff(max_attempts=3)
    def query_vector_store(self, query):
        """查询向量存储"""
        # 模拟向量查询
        return ["doc1", "doc2", "doc3"]
    
    @circuit_breaker_decorator
    def generate_response(self, context, query):
        """生成回答"""
        # 模拟LLM调用
        return f"基于上下文的回答: {query}"
    
    def search(self, query):
        """搜索接口"""
        try:
            # 查询向量存储
            docs = self.query_vector_store(query)
            
            # 生成回答
            response = self.generate_response(docs, query)
            
            return {"success": True, "response": response}
        except Exception as e:
            return {"success": False, "error": str(e)}

# 测试集成效果
rag_service = RobustRAGService()
for i in range(10):
    result = rag_service.search(f"查询{i}")
    print(f"搜索 {i+1}: {result}")
```

#### 4.2 最佳实践总结 (2分钟)
1. **故障注入原则**:
   - 从小概率开始，逐步增加
   - 在测试环境充分验证
   - 监控系统行为变化

2. **恢复机制设计**:
   - 多层防护：重试→熔断→降级
   - 合理配置参数
   - 及时监控和告警

3. **生产环境应用**:
   - 渐进式部署
   - 完善的监控体系
   - 快速回滚机制

## 课堂互动环节

### 问题讨论 (课程中穿插)
1. **Q**: 什么情况下应该使用故障注入？
   **A**: 系统上线前测试、容灾演练、性能压测

2. **Q**: 熔断器的三种状态分别是什么？
   **A**: CLOSED(正常)、OPEN(熔断)、HALF_OPEN(半开)

3. **Q**: 如何选择合适的重试策略？
   **A**: 根据服务特性：快速服务用固定延迟，慢服务用指数退避

### 实践要点提醒
1. **安全性**: 故障注入仅在测试环境使用
2. **监控**: 实时观察系统指标变化
3. **恢复**: 确保有快速恢复机制
4. **文档**: 记录故障场景和处理方案

## 课后作业
1. 在自己的项目中实现一个简单的重试机制
2. 设计一个熔断器来保护关键服务
3. 思考：如何在微服务架构中应用这些模式？

## 扩展阅读
- 《Release It!》- Michael Nygard
- 《Building Microservices》- Sam Newman
- Netflix Hystrix 文档
- Chaos Engineering 相关资料

---

**注意事项**:
- 确保学生理解故障注入的目的和价值
- 强调在生产环境中的谨慎使用
- 鼓励学生在实际项目中应用这些技术
- 提醒关注系统的可观测性和监控