# Lesson 15 教师讲稿（照读脚本）

## 时间轴与环节
- 开场（3’）
- 目标与产物（7’）
- 核心概念讲解（15’）
- 架构与实现要点（10’）
- 端到端演示（20’）
- 故障注入与恢复（15’）
- 指标复盘与提交要求（10’）
- 问答与总结（10’）

## 开场话术（可照读）
- 今天我们聚焦“批量断点续传”的工程化能力。目标是让批处理在故障场景下可恢复、可观测、可度量，并与后续增量更新形成契约。
- 产物包括：检查点与状态机实现、幂等键与去重、重试退避、降级策略，以及完整的实验数据与验收截图。

## 核心术语与定义
- 检查点（checkpoint）：记录处理进度的持久化标记（offset/marker）。
- 幂等（idempotency）：多次执行结果一致，通过键与去重保证工程上可接受的一致性。
- 投递语义：exactly-once vs at-least-once 的工程权衡与落地策略。
- 指数退避：失败后按指数增加等待时间并加抖动，避免雪崩与拥塞。

## 架构与实现要点（讲解脚本）
- 批处理切分：分批窗口、任务划分；文档级并发、分块内同步，避免跨块边界并发。
- 检查点持久化：按 `batch_id` 与分片标识记录进度，写入时使用租约或轻量锁避免竞态。
- 幂等键设计：`source + normalized_id + content_hash + layer`，避免使用易碰撞的自增 ID。
- 重试与退避：最大重试次数、指数退避与抖动；失败降级（简化清洗+固定分块）保障整体收敛。
- 可观测性：输出完成数、失败数、重复率、吞吐与恢复时间；记录 `last_error` 与失败原因分布。

## 端到端演示（步骤与话术）
1. 展示 `examples/input_example.json` 的批量输入结构与关键字段（doc_ids、metadata）。
2. 首次运行批处理，引导学生观察日志中的进度、失败与重试记录；指出检查点写入位置与命名。
3. 注入故障：提高解析失败概率或让外部模型短暂超时；再次运行以观察恢复策略与指标变化。
4. 从检查点恢复：确认仅处理未完成项；核对重复率 ≤ 1%，记录恢复耗时。
5. 打开 `checklist.md`，逐条对照验收标准并现场勾选。

## 课堂提问与互动（含参考答案）
- 问：为什么工程实践偏向 at-least-once + 幂等？答：复杂度与开销更低，结合去重可达工程可接受的一致性。
- 问：检查点该如何分层？答：按批次/分片/对象分层，避免热点；必要时引入局部锁或租约。
- 问：如何度量重复率与恢复时间？答：输出 `dup_rate` 与 `resume_time`，通过日志/统计接口采集并展示。

## 总结话术
- 批量断点续传的关键在于“正确的键与状态治理”，辅以“可观测与兜底策略”。
- 与下一课的增量更新强关联：今天的幂等键与失效策略，将用于索引重建与缓存失效。

## 提交要求与验收复盘
- 提交内容：实现简述、配置参数、实验数据（两次运行：首次与恢复）、日志与截图。
- 验收阈值：完成率 ≥ 99%，重复率 ≤ 1%，恢复时间 ≤ 1 分钟；错误结构统一且可追溯。