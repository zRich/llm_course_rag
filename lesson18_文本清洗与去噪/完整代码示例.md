# 第18节课 - 文本清洗与去噪完整代码示例

## 1. 文本清洗器 (TextCleaner)

```python
import re
from typing import Dict, List, Optional

class TextCleaner:
    """文本清洗器 - 用于清理和规范化文本数据"""
    
    def __init__(self, config: Dict = None):
        """初始化文本清洗器"""
        self.config = config or {}
        self.min_line_length = self.config.get('min_line_length', 3)
        self.max_line_length = self.config.get('max_line_length', 500)
        self.remove_duplicates = self.config.get('remove_duplicates', True)
        
        # 初始化清洗规则
        self._init_cleaning_rules()
    
    def _init_cleaning_rules(self):
        """初始化清洗规则"""
        # 无意义内容的正则模式
        self.meaningless_patterns = [
            re.compile(r'^\s*[=\-_]{3,}\s*$'),  # 分隔线
            re.compile(r'^\s*第?\d+页\s*$'),     # 页码
            re.compile(r'^\s*\d+\s*$'),         # 纯数字
            re.compile(r'^\s*[\*\+\-]{3,}\s*$'), # 符号分隔
            re.compile(r'^\s*目录\s*$'),        # 目录标题
            re.compile(r'^\s*附录[A-Z]?\s*$')   # 附录标题
        ]
        
        # 特殊字符替换映射
        self.char_replacements = {
            '…': '...',
            '—': '-',
            '–': '-',
            '•': '*',
            '·': '*',
            '　': ' '
        }
    
    def clean_text(self, text: str) -> Dict[str, any]:
        """清洗文本的主要方法"""
        if not text or not isinstance(text, str):
            return self._empty_result()
        
        original_length = len(text)
        
        # 执行清洗步骤
        text = self._normalize_whitespace(text)
        text = self._replace_special_chars(text)
        
        # 按行处理
        lines = text.split('\n')
        cleaned_lines = []
        lines_removed = 0
        
        for line in lines:
            cleaned_line = self._clean_line(line)
            if cleaned_line and self._is_valid_line(cleaned_line):
                cleaned_lines.append(cleaned_line)
            else:
                lines_removed += 1
        
        # 移除重复行
        if self.remove_duplicates:
            cleaned_lines = self._remove_duplicate_lines(cleaned_lines)
        
        # 重新组合文本
        cleaned_text = '\n'.join(cleaned_lines)
        
        # 计算质量评分
        quality_score = self._calculate_quality_score(cleaned_text)
        
        return {
            'cleaned_text': cleaned_text,
            'original_length': original_length,
            'cleaned_length': len(cleaned_text),
            'lines_removed': lines_removed,
            'compression_ratio': len(cleaned_text) / original_length if original_length > 0 else 0,
            'quality_score': quality_score
        }
    
    def _normalize_whitespace(self, text: str) -> str:
        """规范化空白符"""
        # 统一换行符
        text = re.sub(r'\r\n|\r', '\n', text)
        
        # 移除行尾空白
        text = re.sub(r'[ \t]+$', '', text, flags=re.MULTILINE)
        
        # 压缩多个空白符为单个空格
        text = re.sub(r'[ \t]+', ' ', text)
        
        # 压缩多个换行符
        text = re.sub(r'\n{3,}', '\n\n', text)
        
        return text.strip()
    
    def _replace_special_chars(self, text: str) -> str:
        """替换特殊字符"""
        for old_char, new_char in self.char_replacements.items():
            text = text.replace(old_char, new_char)
        return text
    
    def _clean_line(self, line: str) -> Optional[str]:
        """清洗单行文本"""
        line = line.strip()
        
        if not line:
            return None
        
        # 检查行长度
        if len(line) < self.min_line_length or len(line) > self.max_line_length:
            return None
        
        # 检查是否为无意义内容
        for pattern in self.meaningless_patterns:
            if pattern.match(line):
                return None
        
        return line
    
    def _is_valid_line(self, line: str) -> bool:
        """验证行是否有效"""
        if not line or len(line.strip()) == 0:
            return False
        
        # 检查字符多样性
        unique_chars = len(set(line.lower()))
        if unique_chars < 2:
            return False
        
        # 检查是否包含有意义的内容
        if not re.search(r'[a-zA-Z\u4e00-\u9fff]', line):
            return False
        
        return True
    
    def _remove_duplicate_lines(self, lines: List[str]) -> List[str]:
        """移除重复行"""
        seen = set()
        unique_lines = []
        
        for line in lines:
            line_key = line.lower().strip()
            if line_key not in seen:
                seen.add(line_key)
                unique_lines.append(line)
        
        return unique_lines
    
    def _calculate_quality_score(self, text: str) -> float:
        """计算文本质量评分"""
        if not text:
            return 0.0
        
        score = 100.0
        
        # 长度检查
        if len(text) < 50:
            score -= 30
        elif len(text) < 100:
            score -= 15
        
        # 字符多样性检查
        unique_chars = len(set(text.lower()))
        if unique_chars < 10:
            score -= 25
        elif unique_chars < 20:
            score -= 10
        
        # 行数检查
        lines = [line for line in text.split('\n') if line.strip()]
        if len(lines) < 3:
            score -= 20
        
        return max(score, 0.0)
    
    def _empty_result(self) -> Dict:
        """返回空结果"""
        return {
            'cleaned_text': '',
            'original_length': 0,
            'cleaned_length': 0,
            'lines_removed': 0,
            'compression_ratio': 0.0,
            'quality_score': 0.0
        }
```

## 2. 编码检测器 (EncodingDetector)

```python
import chardet
from typing import Dict, Tuple

class EncodingDetector:
    """编码检测和修复器"""
    
    def __init__(self, confidence_threshold: float = 0.7):
        """初始化编码检测器"""
        self.confidence_threshold = confidence_threshold
        
        # 乱码修复映射
        self.mojibake_fixes = {
            'â€™': "'",
            'â€œ': '"',
            'â€\x9d': '"',
            'â€