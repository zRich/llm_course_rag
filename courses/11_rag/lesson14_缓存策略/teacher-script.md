# Lesson 14 · 教师讲稿（缓存策略）

## 时间轴（90 分钟）
- 0–10 开场：目标与评估口径（命中率、P95、成本）
- 10–30 概念：分层缓存、键设计、TTL/主动失效、预热与分层
- 30–55 演示：两次调用对比；预热；失效后重试；日志与指标
- 55–80 互动：设计键覆盖；诊断伪命中；命中率提升策略讨论
- 80–90 总结：提交要求与验收标准、边界与合规提醒

## 开场话术
今天我们把注意力放在“快”和“省”，但不牺牲“准”。通过合理的缓存策略，我们在热问场景里把命中率做上去，把 P95 延时和调用成本降下来，同时确保引用与答案的一致性不被破坏。

## 核心术语速讲
- 缓存键：覆盖所有影响结果的输入维度的组合键（查询、过滤、模型、提示、样式等）。
- 分层缓存：Embedding/检索/重排/QA 四层。
- TTL 与主动失效：到期自动清理；文档更新或版本变更触发清理。
- 预热与分层：课前/上线前对热问预热；冷热分层管理容量与 TTL。

## 演示脚本（可现场复用）
1) 展示 `.env` 片段：`CACHE_ENABLED=true`、`CACHE_TTL_SEC=300`、`CACHE_KEY_FIELDS=[...]`。
2) 第一次调用检索与 QA：观察日志 `cache_hit=false`，记录延时/成本与引用字段。
3) 第二次同参调用：观察日志 `cache_hit=true`，延时显著下降，引用与答案一致。
4) 预热脚本：对 Top-10 热问批量调用一次，展示命中率提升。
5) 失效演示：修改一份源文档，触发失效；再次调用为 `miss`，返回更新后的引用片段。

## 互动与提问
- 若 `query` 大小写不同是否命中？如何标准化？
- `filters` 字段顺序不同为何导致未命中？如何做规范序列化？
- 哪些版本变更需要强制失效？模型、索引、提示三个维度如何纳入键？
- 如何避免 TTL 同时到期造成雪崩？

## 常见误区与应对话术
- 误区：仅用 `query` 做键，忽略 `filters/top_k/rerank/style`，导致伪命中。
  - 应对：展示键字段清单与 Canonical JSON 的必要性。
- 误区：缓存 QA 但上下文变了仍命中。
  - 应对：将 `context_ids_hash` 纳入键；文档更新触发主动失效。
- 误区：全局缓存污染多租户数据。
  - 应对：在键空间中加入 `tenant_id/user_id`。

## 总结与提交要求
- 必须提交命中率、P95 延时与成本三项对比；附原始日志/截图。
- 提交 `.env`、预热与失效脚本；随机抽样的一致性核验结果。
- 严禁虚构或伪造数据与截图；引用字段与样式保持一致。