# 第八节课：混合检索融合策略 - 学生实验指导

## 实验目标
通过本实验，学生将：
1. 理解混合检索的基本原理和实现方法
2. 掌握向量检索与关键词检索的融合技术
3. 学会调节融合权重以优化检索效果
4. 了解A/B测试在检索优化中的应用

## 实验环境准备

### 前置条件
- 完成前7节课的学习，特别是第6节课（向量检索）和第7节课（关键词检索）
- 确保rag-system项目正常运行
- Python环境已安装必要依赖

### 实验数据
本实验将使用模拟的检索结果数据，无需额外的数据准备。

## 实验步骤

### 步骤1：创建混合检索融合模块（10分钟）

在项目中创建新文件 `app/services/hybrid_search.py`：

```python
from typing import List, Dict, Tuple, Any
import logging

logger = logging.getLogger(__name__)

class HybridSearchFusion:
    """
    混合检索融合服务
    结合向量检索和关键词检索的结果
    """
    
    def __init__(self, default_vector_weight: float = 0.6, default_keyword_weight: float = 0.4):
        self.default_vector_weight = default_vector_weight
        self.default_keyword_weight = default_keyword_weight
    
    def fuse_results(
        self, 
        vector_results: List[Dict[str, Any]], 
        keyword_results: List[Dict[str, Any]],
        vector_weight: float = None,
        keyword_weight: float = None
    ) -> List[Dict[str, Any]]:
        """
        融合向量检索和关键词检索结果
        
        Args:
            vector_results: 向量检索结果列表
            keyword_results: 关键词检索结果列表
            vector_weight: 向量检索权重
            keyword_weight: 关键词检索权重
        
        Returns:
            融合后的检索结果列表
        """
        # 使用默认权重或传入权重
        v_weight = vector_weight or self.default_vector_weight
        k_weight = keyword_weight or self.default_keyword_weight
        
        # 确保权重和为1
        total_weight = v_weight + k_weight
        v_weight = v_weight / total_weight
        k_weight = k_weight / total_weight
        
        logger.info(f"融合权重 - 向量: {v_weight:.3f}, 关键词: {k_weight:.3f}")
        
        # 存储融合结果
        fused_docs = {}
        
        # 处理向量检索结果
        for result in vector_results:
            doc_id = result.get('id') or result.get('document_id')
            if not doc_id:
                continue
                
            fused_docs[doc_id] = {
                'id': doc_id,
                'content': result.get('content', ''),
                'metadata': result.get('metadata', {}),
                'vector_score': result.get('score', 0),
                'keyword_score': 0,
                'final_score': v_weight * result.get('score', 0),
                'source': 'vector'
            }
        
        # 处理关键词检索结果
        for result in keyword_results:
            doc_id = result.get('id') or result.get('document_id')
            if not doc_id:
                continue
                
            keyword_score = result.get('score', 0)
            
            if doc_id in fused_docs:
                # 文档已存在，更新得分
                fused_docs[doc_id]['keyword_score'] = keyword_score
                fused_docs[doc_id]['final_score'] += k_weight * keyword_score
                fused_docs[doc_id]['source'] = 'both'
            else:
                # 新文档
                fused_docs[doc_id] = {
                    'id': doc_id,
                    'content': result.get('content', ''),
                    'metadata': result.get('metadata', {}),
                    'vector_score': 0,
                    'keyword_score': keyword_score,
                    'final_score': k_weight * keyword_score,
                    'source': 'keyword'
                }
        
        # 按最终得分排序
        sorted_results = sorted(
            fused_docs.values(),
            key=lambda x: x['final_score'],
            reverse=True
        )
        
        logger.info(f"融合完成，共 {len(sorted_results)} 个文档")
        return sorted_results
    
    def normalize_scores(self, results: List[Dict[str, Any]], score_field: str = 'score') -> List[Dict[str, Any]]:
        """
        归一化得分到0-1区间
        """
        if not results:
            return results
        
        scores = [r.get(score_field, 0) for r in results]
        max_score = max(scores) if scores else 1
        min_score = min(scores) if scores else 0
        
        if max_score == min_score:
            return results
        
        for result in results:
            original_score = result.get(score_field, 0)
            normalized_score = (original_score - min_score) / (max_score - min_score)
            result[f'normalized_{score_field}'] = normalized_score
        
        return results
```

### 步骤2：创建A/B测试框架（5分钟）

在同一文件中添加A/B测试类：

```python
class ABTestFramework:
    """
    简单的A/B测试框架
    用于对比不同融合策略的效果
    """
    
    def __init__(self):
        self.test_results = {}
    
    def run_test(
        self, 
        test_name: str,
        vector_results: List[Dict[str, Any]], 
        keyword_results: List[Dict[str, Any]],
        strategies: Dict[str, Tuple[float, float]]
    ) -> Dict[str, Any]:
        """
        运行A/B测试
        
        Args:
            test_name: 测试名称
            vector_results: 向量检索结果
            keyword_results: 关键词检索结果
            strategies: 策略配置 {策略名: (向量权重, 关键词权重)}
        
        Returns:
            测试结果
        """
        fusion_service = HybridSearchFusion()
        test_result = {
            'test_name': test_name,
            'strategies': {},
            'summary': {}
        }
        
        for strategy_name, (v_weight, k_weight) in strategies.items():
            # 执行融合
            fused_results = fusion_service.fuse_results(
                vector_results, keyword_results, v_weight, k_weight
            )
            
            # 计算指标
            metrics = self._calculate_metrics(fused_results)
            
            test_result['strategies'][strategy_name] = {
                'weights': (v_weight, k_weight),
                'results': fused_results[:5],  # 只保存前5个结果
                'metrics': metrics
            }
        
        # 生成总结
        test_result['summary'] = self._generate_summary(test_result['strategies'])
        
        # 保存测试结果
        self.test_results[test_name] = test_result
        
        return test_result
    
    def _calculate_metrics(self, results: List[Dict[str, Any]]) -> Dict[str, float]:
        """
        计算评估指标
        """
        if not results:
            return {'avg_score': 0, 'top_3_avg': 0, 'diversity': 0}
        
        scores = [r['final_score'] for r in results]
        top_3_scores = scores[:3] if len(scores) >= 3 else scores
        
        # 计算来源多样性
        sources = [r['source'] for r in results[:10]]
        diversity = len(set(sources)) / len(sources) if sources else 0
        
        return {
            'avg_score': sum(scores) / len(scores),
            'top_3_avg': sum(top_3_scores) / len(top_3_scores),
            'diversity': diversity,
            'total_docs': len(results)
        }
    
    def _generate_summary(self, strategies: Dict[str, Any]) -> Dict[str, Any]:
        """
        生成测试总结
        """
        best_strategy = None
        best_score = -1
        
        for strategy_name, data in strategies.items():
            avg_score = data['metrics']['avg_score']
            if avg_score > best_score:
                best_score = avg_score
                best_strategy = strategy_name
        
        return {
            'best_strategy': best_strategy,
            'best_score': best_score,
            'total_strategies': len(strategies)
        }
    
    def print_test_results(self, test_name: str):
        """
        打印测试结果
        """
        if test_name not in self.test_results:
            print(f"测试 '{test_name}' 不存在")
            return
        
        result = self.test_results[test_name]
        print(f"\n=== A/B测试结果: {test_name} ===")
        
        for strategy_name, data in result['strategies'].items():
            weights = data['weights']
            metrics = data['metrics']
            
            print(f"\n策略: {strategy_name}")
            print(f"权重配置: 向量={weights[0]:.1f}, 关键词={weights[1]:.1f}")
            print(f"平均得分: {metrics['avg_score']:.4f}")
            print(f"前3平均: {metrics['top_3_avg']:.4f}")
            print(f"来源多样性: {metrics['diversity']:.2f}")
            print(f"文档总数: {metrics['total_docs']}")
        
        summary = result['summary']
        print(f"\n最佳策略: {summary['best_strategy']} (得分: {summary['best_score']:.4f})")
```

### 步骤3：创建测试脚本（实验主体）

创建文件 `test_hybrid_search.py`：

```python
#!/usr/bin/env python3
"""
混合检索融合策略测试脚本
"""

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app.services.hybrid_search import HybridSearchFusion, ABTestFramework

def create_mock_data():
    """
    创建模拟测试数据
    """
    # 模拟向量检索结果
    vector_results = [
        {
            "id": "doc_001",
            "content": "人工智能是计算机科学的一个分支，致力于创建能够执行通常需要人类智能的任务的系统。",
            "score": 0.85,
            "metadata": {"source": "AI教程", "page": 1}
        },
        {
            "id": "doc_002", 
            "content": "机器学习是人工智能的一个子领域，专注于算法和统计模型的开发。",
            "score": 0.78,
            "metadata": {"source": "ML指南", "page": 5}
        },
        {
            "id": "doc_003",
            "content": "深度学习使用多层神经网络来学习数据的复杂模式和表示。",
            "score": 0.72,
            "metadata": {"source": "DL手册", "page": 12}
        },
        {
            "id": "doc_004",
            "content": "自然语言处理结合了计算机科学、人工智能和语言学的技术。",
            "score": 0.68,
            "metadata": {"source": "NLP基础", "page": 3}
        }
    ]
    
    # 模拟关键词检索结果
    keyword_results = [
        {
            "id": "doc_002",
            "content": "机器学习是人工智能的一个子领域，专注于算法和统计模型的开发。",
            "score": 0.92,
            "metadata": {"source": "ML指南", "page": 5}
        },
        {
            "id": "doc_005",
            "content": "人工智能技术在医疗诊断、金融分析和自动驾驶等领域有广泛应用。",
            "score": 0.88,
            "metadata": {"source": "AI应用", "page": 8}
        },
        {
            "id": "doc_001",
            "content": "人工智能是计算机科学的一个分支，致力于创建能够执行通常需要人类智能的任务的系统。",
            "score": 0.65,
            "metadata": {"source": "AI教程", "page": 1}
        },
        {
            "id": "doc_006",
            "content": "人工智能的发展历程可以追溯到20世纪50年代的达特茅斯会议。",
            "score": 0.58,
            "metadata": {"source": "AI历史", "page": 2}
        }
    ]
    
    return vector_results, keyword_results

def test_basic_fusion():
    """
    测试基本融合功能
    """
    print("=== 基本融合测试 ===")
    
    vector_results, keyword_results = create_mock_data()
    fusion_service = HybridSearchFusion()
    
    # 使用默认权重进行融合
    fused_results = fusion_service.fuse_results(vector_results, keyword_results)
    
    print(f"\n融合结果 (默认权重 0.6:0.4):")
    for i, result in enumerate(fused_results[:5]):
        print(f"{i+1}. {result['id']}")
        print(f"   最终得分: {result['final_score']:.4f}")
        print(f"   向量得分: {result['vector_score']:.4f}")
        print(f"   关键词得分: {result['keyword_score']:.4f}")
        print(f"   来源: {result['source']}")
        print(f"   内容: {result['content'][:50]}...")
        print()

def test_weight_adjustment():
    """
    测试权重调节
    """
    print("=== 权重调节测试 ===")
    
    vector_results, keyword_results = create_mock_data()
    fusion_service = HybridSearchFusion()
    
    weight_configs = [
        (0.8, 0.2, "向量优先"),
        (0.5, 0.5, "平衡策略"),
        (0.2, 0.8, "关键词优先")
    ]
    
    for v_weight, k_weight, strategy_name in weight_configs:
        print(f"\n{strategy_name} (向量:{v_weight}, 关键词:{k_weight}):")
        
        fused_results = fusion_service.fuse_results(
            vector_results, keyword_results, v_weight, k_weight
        )
        
        for i, result in enumerate(fused_results[:3]):
            print(f"  {i+1}. {result['id']}: {result['final_score']:.4f}")

def test_ab_framework():
    """
    测试A/B测试框架
    """
    print("=== A/B测试框架测试 ===")
    
    vector_results, keyword_results = create_mock_data()
    ab_test = ABTestFramework()
    
    # 定义测试策略
    strategies = {
        "向量优先策略": (0.7, 0.3),
        "平衡策略": (0.5, 0.5),
        "关键词优先策略": (0.3, 0.7),
        "极端向量策略": (0.9, 0.1)
    }
    
    # 运行A/B测试
    test_result = ab_test.run_test(
        "人工智能查询测试",
        vector_results,
        keyword_results,
        strategies
    )
    
    # 打印结果
    ab_test.print_test_results("人工智能查询测试")

def interactive_weight_tuning():
    """
    交互式权重调节
    """
    print("=== 交互式权重调节 ===")
    print("输入权重值来测试不同的融合效果")
    print("格式: 向量权重,关键词权重 (例如: 0.6,0.4)")
    print("输入 'quit' 退出")
    
    vector_results, keyword_results = create_mock_data()
    fusion_service = HybridSearchFusion()
    
    while True:
        try:
            user_input = input("\n请输入权重配置: ").strip()
            
            if user_input.lower() == 'quit':
                break
            
            v_weight, k_weight = map(float, user_input.split(','))
            
            if v_weight < 0 or k_weight < 0:
                print("权重不能为负数")
                continue
            
            fused_results = fusion_service.fuse_results(
                vector_results, keyword_results, v_weight, k_weight
            )
            
            print(f"\n权重配置 - 向量: {v_weight}, 关键词: {k_weight}")
            print("前5个结果:")
            
            for i, result in enumerate(fused_results[:5]):
                print(f"{i+1}. {result['id']}: {result['final_score']:.4f} ({result['source']})")
                
        except ValueError:
            print("输入格式错误，请使用格式: 0.6,0.4")
        except KeyboardInterrupt:
            break
    
    print("\n交互式测试结束")

def main():
    """
    主函数
    """
    print("混合检索融合策略实验")
    print("=" * 50)
    
    # 运行所有测试
    test_basic_fusion()
    print("\n" + "="*50 + "\n")
    
    test_weight_adjustment()
    print("\n" + "="*50 + "\n")
    
    test_ab_framework()
    print("\n" + "="*50 + "\n")
    
    # 可选的交互式测试
    choice = input("是否进行交互式权重调节测试？(y/n): ").strip().lower()
    if choice == 'y':
        interactive_weight_tuning()
    
    print("\n实验完成！")

if __name__ == "__main__":
    main()
```

## 实验任务

### 任务1：基础融合实验
1. 运行测试脚本：`python test_hybrid_search.py`
2. 观察默认权重(0.6:0.4)下的融合结果
3. 分析哪些文档同时出现在两种检索结果中
4. 记录融合后的排序变化

### 任务2：权重调节实验
1. 测试不同权重配置的效果
2. 观察权重变化对结果排序的影响
3. 思考：什么情况下应该偏向向量检索？什么情况下偏向关键词检索？

### 任务3：A/B测试实验
1. 运行A/B测试框架
2. 分析不同策略的评估指标
3. 确定最佳策略配置
4. 思考：如何在实际应用中选择合适的策略？

### 任务4：交互式调优
1. 使用交互式权重调节功能
2. 尝试极端权重配置（如0.9,0.1或0.1,0.9）
3. 观察结果的变化趋势
4. 找到你认为最优的权重配置

## 实验报告要求

请完成以下实验报告：

### 1. 实验结果记录
- 记录不同权重配置下的前5个检索结果
- 对比分析结果的差异

### 2. 策略分析
- 分析向量优先策略的优缺点
- 分析关键词优先策略的优缺点
- 分析平衡策略的适用场景

### 3. 优化建议
- 基于实验结果，提出权重配置的优化建议
- 讨论如何根据查询类型动态调整权重

### 4. 思考题回答
1. 如何确定融合权重 alpha/beta？
2. 当两个检索结果冲突时，如何处理优先级？
3. 混合检索在什么场景下效果最好？
4. 如何评估混合检索的效果？

## 扩展实验（可选）

### 扩展1：得分归一化
修改融合算法，添加得分归一化功能，观察对结果的影响。

### 扩展2：动态权重
实现基于查询内容自动调整权重的功能。

### 扩展3：多指标评估
添加更多评估指标，如精确率、召回率等。

## 常见问题解决

**Q1：运行测试脚本时出现导入错误**
A1：确保在正确的目录下运行脚本，并检查Python路径设置。

**Q2：融合结果为空**
A2：检查输入数据格式，确保包含必要的字段（id、score、content）。

**Q3：权重调节没有明显效果**
A3：检查输入数据的得分分布，可能需要更大的权重差异才能看到明显变化。

## 实验总结

通过本实验，你应该掌握：
1. 混合检索融合的基本原理和实现方法
2. 权重调节对检索结果的影响
3. A/B测试在检索优化中的应用
4. 如何根据实际需求选择合适的融合策略

这些技能将为后续的检索系统优化和实际项目应用打下坚实基础。